// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

enum CacheType { Address, Uint, Int, Byte, Bool }

/**
 * @notice This struct manages the cache of the library instance.
 * @param addresses A mapping of address values mapped to cache keys in bytes.
 * @param uints A mapping of uint values mapped to cache keys names in bytes.
 * @param ints A mapping of int values mapped to cache keys names in bytes.
 * @param bites A mapping of bytes values mapped to cache keys names in bytes.
 * @param bools A mapping of bool values mapped to cache keys names in bytes.
 */
struct Cache {
    // Mapping of cache keys names to address values.
    mapping(bytes32 => address) addresses;
    // Mapping of cache keys names to uint256 values.
    mapping(bytes32 => uint256) uints;
    // Mapping of cache keys names to int256 values.
    mapping(bytes32 => int256) ints;
    // Mapping of cache keys names to bytes32 values.
    mapping(bytes32 => bytes32) bites;
    // Mapping of cache keys names to bool values.
    mapping(bytes32 => bool) bools;
}

library CacheLib {
    // The constant for the initialization check
    bytes32 private constant INITIALIZED = keccak256("Initialized");

    /**
     * @notice Initializes the cache instance.
     * @param cache The current cache
     */
    function initialize(Cache storage cache) internal {
        requireNotExists(cache);
        cache.bools[INITIALIZED] = true;
    }

    /**
     * @notice Checks whether the current cache does not, throwing an error if it does.
     * @param cache The current cache
     */
    function requireNotExists(Cache storage cache) internal view {
        require(!exists(cache), "CACHE_ALREADY_EXISTS");
    }

    /**
     * @notice Checks whether the current cache exists, throwing an error if the cache does not.
     * @param cache The current cache
     */
    function requireExists(Cache storage cache) internal view {
        require(exists(cache), "CACHE_DOES_NOT_EXIST");
    }

    /**
     * @notice Tests whether the current cache exists or not.
     * @param cache The current cache.
     * @return bool True if the cache exists.
     */
    function exists(Cache storage cache) internal view returns (bool) {
        return cache.bools[INITIALIZED];
    }

    /**
     * @notice it updates the cache with a key, value and cache type
     * @param cache cache to update
     * @param key the memory reference to the value in bytes32
     * @param value the value to update at the key
     * @param cacheType the enum type of cache to update
     */
    function update(
        Cache storage cache,
        bytes32 key,
        bytes32 value,
        CacheType cacheType
    ) internal {
        requireExists(cache);

        assembly {
            mstore(0, value)
        }
        if (cacheType == CacheType.Address) {
            address addr;
            assembly {
                addr := mload(0)
            }
            cache.addresses[key] = addr;
        } else if (cacheType == CacheType.Uint) {
            uint256 ui;
            assembly {
                ui := mload(0)
            }
            cache.uints[key] = ui;
        } else if (cacheType == CacheType.Int) {
            int256 i;
            assembly {
                i := mload(0)
            }
            cache.ints[key] = i;
        } else if (cacheType == CacheType.Byte) {
            cache.bites[key] = value;
        } else if (cacheType == CacheType.Bool) {
            bool b;
            assembly {
                b := mload(0)
            }
            cache.bools[key] = b;
        }
    }

    /**
     * @notice it deletes the cache values at the specified key
     * @param cache the cache to delete keys from
     * @param keysToClear the keys to delete
     * @param keyTypes the types of keys to target different parts of the cache
     */
    function clearCache(
        Cache storage cache,
        bytes32[5] memory keysToClear,
        CacheType[5] memory keyTypes
    ) internal {
        requireExists(cache);
        require(
            keysToClear.length == keyTypes.length,
            "ARRAY_LENGTHS_MISMATCH"
        );
        for (uint256 i; i <= keysToClear.length; i++) {
            if (keyTypes[i] == CacheType.Address) {
                delete cache.addresses[keysToClear[i]];
            } else if (keyTypes[i] == CacheType.Uint) {
                delete cache.uints[keysToClear[i]];
            } else if (keyTypes[i] == CacheType.Int) {
                delete cache.ints[keysToClear[i]];
            } else if (keyTypes[i] == CacheType.Byte) {
                delete cache.bites[keysToClear[i]];
            } else if (keyTypes[i] == CacheType.Bool) {
                delete cache.bools[keysToClear[i]];
            }
        }
    }
}
