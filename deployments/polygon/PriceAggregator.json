{
  "address": "0xE5aE32Be9a0c5c77478fC0c80C68a53f74a85de9",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "wETHAddress",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "chainlinkPricerAddress",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "chainlinkPricer",
      "outputs": [
        {
          "internalType": "contract ChainlinkPricer",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "src",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "dst",
          "type": "address"
        }
      ],
      "name": "getBalanceOfFor",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "src",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "dst",
          "type": "address"
        }
      ],
      "name": "getPriceFor",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "src",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "dst",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "srcAmount",
          "type": "uint256"
        }
      ],
      "name": "getValueFor",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "saLPPricer",
      "outputs": [
        {
          "internalType": "contract IsaLPPricer",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "asset",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "pricer",
          "type": "address"
        }
      ],
      "name": "setAssetPricer",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "pricer",
          "type": "address"
        },
        {
          "internalType": "address[]",
          "name": "assets",
          "type": "address[]"
        }
      ],
      "name": "setAssetPricers",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "wETH",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "artifactName": "PriceAggregator",
  "transactionHash": "0xef5890adde3e733c7f01061caf6e2b889439144b361ad8d7d6cc0515c36fba27",
  "receipt": {
    "to": null,
    "from": "0xAFe87013dc96edE1E116a288D80FcaA0eFFE5fe5",
    "contractAddress": "0xE5aE32Be9a0c5c77478fC0c80C68a53f74a85de9",
    "transactionIndex": 55,
    "gasUsed": "917270",
    "logsBloom": "0x00000000000000000000000000008000000000000020000000000000000000000000000000000000000000000000000000008000000000000000000000000000000004000000000000000000000000800100000000000000000100000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000800000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000004000000000000100000001000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000100000",
    "blockHash": "0x6b9e9fc5458914d0bb678a232d94851496aa5620e0def9a57eff03494e0f8f38",
    "transactionHash": "0xef5890adde3e733c7f01061caf6e2b889439144b361ad8d7d6cc0515c36fba27",
    "logs": [
      {
        "transactionIndex": 55,
        "blockNumber": 16863187,
        "transactionHash": "0xef5890adde3e733c7f01061caf6e2b889439144b361ad8d7d6cc0515c36fba27",
        "address": "0x0000000000000000000000000000000000001010",
        "topics": [
          "0x4dfe1bbbcf077ddc3e01291eea2d5c70c2b422b415d95645b9adcfd678cb1d63",
          "0x0000000000000000000000000000000000000000000000000000000000001010",
          "0x000000000000000000000000afe87013dc96ede1e116a288d80fcaa0effe5fe5",
          "0x0000000000000000000000007b5000af8ab69fd59eb0d4f5762bff57c9c04385"
        ],
        "data": "0x00000000000000000000000000000000000000000000000000209685a521980000000000000000000000000000000000000000000000001c058fb63d62b4acdf00000000000000000000000000000000000000000000224bbad521ce53a41edc00000000000000000000000000000000000000000000001c056f1fb7bd9314df00000000000000000000000000000000000000000000224bbaf5b853f8c5b6dc",
        "logIndex": 75,
        "blockHash": "0x6b9e9fc5458914d0bb678a232d94851496aa5620e0def9a57eff03494e0f8f38"
      }
    ],
    "blockNumber": 16863187,
    "cumulativeGasUsed": "4004298",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619",
    "0x0439931527216FE417d81E367fb4E02b6E939883"
  ],
  "solcInputHash": "b5f251bb9db269a299bc010c3a1160db",
  "metadata": "{\"compiler\":{\"version\":\"0.8.4+commit.c7e474f2\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wETHAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"chainlinkPricerAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"chainlinkPricer\",\"outputs\":[{\"internalType\":\"contract ChainlinkPricer\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"}],\"name\":\"getBalanceOfFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"}],\"name\":\"getPriceFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"srcAmount\",\"type\":\"uint256\"}],\"name\":\"getValueFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"saLPPricer\",\"outputs\":[{\"internalType\":\"contract IsaLPPricer\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"pricer\",\"type\":\"address\"}],\"name\":\"setAssetPricer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pricer\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"assets\",\"type\":\"address[]\"}],\"name\":\"setAssetPricers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"getBalanceOfFor(address,address,address)\":{\"params\":{\"account\":\"Address of the account to get the balance value of.\",\"dst\":\"Destination token address.\",\"src\":\"Source token address.\"},\"returns\":{\"_0\":\"Value of the {src} token balance denoted in {dst} tokens.\"}},\"getPriceFor(address,address)\":{\"details\":\"It tries to use ETH as a pass through asset if the direct pair is not supported.\",\"params\":{\"dst\":\"Destination token address.\",\"src\":\"Source token address.\"},\"returns\":{\"_0\":\"uint256 The latest answer as given from Chainlink.\"}},\"getValueFor(address,address,uint256)\":{\"params\":{\"dst\":\"Destination token address.\",\"src\":\"Source token address.\",\"srcAmount\":\"Amount of the source token to convert into the destination token.\"},\"returns\":{\"_0\":\"uint256 Value of the source token amount in destination tokens.\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"getBalanceOfFor(address,address,address)\":{\"notice\":\"It calculates the value of the {src} token balance in {dst} token for the {account}.\"},\"getPriceFor(address,address)\":{\"notice\":\"It returns the price of the token pair as given from the Chainlink Aggregator.\"},\"getValueFor(address,address,uint256)\":{\"notice\":\"It calculates the value of a token amount into another.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/price-aggregator/PriceAggregator.sol\":\"PriceAggregator\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@chainlink/contracts/src/v0.8/interfaces/AggregatorInterface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AggregatorInterface {\\n  function latestAnswer()\\n    external\\n    view\\n    returns (\\n      int256\\n    );\\n  \\n  function latestTimestamp()\\n    external\\n    view\\n    returns (\\n      uint256\\n    );\\n\\n  function latestRound()\\n    external\\n    view\\n    returns (\\n      uint256\\n    );\\n\\n  function getAnswer(\\n    uint256 roundId\\n  )\\n    external\\n    view\\n    returns (\\n      int256\\n    );\\n\\n  function getTimestamp(\\n    uint256 roundId\\n  )\\n    external\\n    view\\n    returns (\\n      uint256\\n    );\\n\\n  event AnswerUpdated(\\n    int256 indexed current,\\n    uint256 indexed roundId,\\n    uint256 updatedAt\\n  );\\n\\n  event NewRound(\\n    uint256 indexed roundId,\\n    address indexed startedBy,\\n    uint256 startedAt\\n  );\\n}\\n\",\"keccak256\":\"0x1a5dc81544a6479f64437a8aca22c869769dd54ee3522c7ef5ebae0d329a28f0\",\"license\":\"MIT\"},\"@chainlink/contracts/src/v0.8/interfaces/AggregatorV2V3Interface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./AggregatorInterface.sol\\\";\\nimport \\\"./AggregatorV3Interface.sol\\\";\\n\\ninterface AggregatorV2V3Interface is AggregatorInterface, AggregatorV3Interface\\n{\\n}\\n\",\"keccak256\":\"0xe8f8d98b515366730824d24269c7267eee7f0288cf737db8659acbb0c751eb53\",\"license\":\"MIT\"},\"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AggregatorV3Interface {\\n\\n  function decimals()\\n    external\\n    view\\n    returns (\\n      uint8\\n    );\\n\\n  function description()\\n    external\\n    view\\n    returns (\\n      string memory\\n    );\\n\\n  function version()\\n    external\\n    view\\n    returns (\\n      uint256\\n    );\\n\\n  // getRoundData and latestRoundData should both raise \\\"No data present\\\"\\n  // if they do not have data to report, instead of returning unset values\\n  // which could be misinterpreted as actual reported values.\\n  function getRoundData(\\n    uint80 _roundId\\n  )\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n}\\n\",\"keccak256\":\"0xe6f5ac8c47f3b9b6135051efb9216f9ba5b312a6ecc20209b4f66a780443c328\",\"license\":\"MIT\"},\"@ensdomains/buffer/contracts/Buffer.sol\":{\"content\":\"pragma solidity ^0.8.4;\\n\\n/**\\n* @dev A library for working with mutable byte buffers in Solidity.\\n*\\n* Byte buffers are mutable and expandable, and provide a variety of primitives\\n* for writing to them. At any time you can fetch a bytes object containing the\\n* current contents of the buffer. The bytes object should not be stored between\\n* operations, as it may change due to resizing of the buffer.\\n*/\\nlibrary Buffer {\\n    /**\\n    * @dev Represents a mutable buffer. Buffers have a current value (buf) and\\n    *      a capacity. The capacity may be longer than the current value, in\\n    *      which case it can be extended without the need to allocate more memory.\\n    */\\n    struct buffer {\\n        bytes buf;\\n        uint capacity;\\n    }\\n\\n    /**\\n    * @dev Initializes a buffer with an initial capacity.\\n    * @param buf The buffer to initialize.\\n    * @param capacity The number of bytes of space to allocate the buffer.\\n    * @return The buffer, for chaining.\\n    */\\n    function init(buffer memory buf, uint capacity) internal pure returns(buffer memory) {\\n        if (capacity % 32 != 0) {\\n            capacity += 32 - (capacity % 32);\\n        }\\n        // Allocate space for the buffer data\\n        buf.capacity = capacity;\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(buf, ptr)\\n            mstore(ptr, 0)\\n            mstore(0x40, add(32, add(ptr, capacity)))\\n        }\\n        return buf;\\n    }\\n\\n    /**\\n    * @dev Initializes a new buffer from an existing bytes object.\\n    *      Changes to the buffer may mutate the original value.\\n    * @param b The bytes object to initialize the buffer with.\\n    * @return A new buffer.\\n    */\\n    function fromBytes(bytes memory b) internal pure returns(buffer memory) {\\n        buffer memory buf;\\n        buf.buf = b;\\n        buf.capacity = b.length;\\n        return buf;\\n    }\\n\\n    function resize(buffer memory buf, uint capacity) private pure {\\n        bytes memory oldbuf = buf.buf;\\n        init(buf, capacity);\\n        append(buf, oldbuf);\\n    }\\n\\n    function max(uint a, uint b) private pure returns(uint) {\\n        if (a > b) {\\n            return a;\\n        }\\n        return b;\\n    }\\n\\n    /**\\n    * @dev Sets buffer length to 0.\\n    * @param buf The buffer to truncate.\\n    * @return The original buffer, for chaining..\\n    */\\n    function truncate(buffer memory buf) internal pure returns (buffer memory) {\\n        assembly {\\n            let bufptr := mload(buf)\\n            mstore(bufptr, 0)\\n        }\\n        return buf;\\n    }\\n\\n    /**\\n    * @dev Writes a byte string to a buffer. Resizes if doing so would exceed\\n    *      the capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param off The start offset to write to.\\n    * @param data The data to append.\\n    * @param len The number of bytes to copy.\\n    * @return The original buffer, for chaining.\\n    */\\n    function write(buffer memory buf, uint off, bytes memory data, uint len) internal pure returns(buffer memory) {\\n        require(len <= data.length);\\n\\n        if (off + len > buf.capacity) {\\n            resize(buf, max(buf.capacity, len + off) * 2);\\n        }\\n\\n        uint dest;\\n        uint src;\\n        assembly {\\n            // Memory address of the buffer data\\n            let bufptr := mload(buf)\\n            // Length of existing buffer data\\n            let buflen := mload(bufptr)\\n            // Start address = buffer address + offset + sizeof(buffer length)\\n            dest := add(add(bufptr, 32), off)\\n            // Update buffer length if we're extending it\\n            if gt(add(len, off), buflen) {\\n                mstore(bufptr, add(len, off))\\n            }\\n            src := add(data, 32)\\n        }\\n\\n        // Copy word-length chunks while possible\\n        for (; len >= 32; len -= 32) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n            dest += 32;\\n            src += 32;\\n        }\\n\\n        // Copy remaining bytes\\n        unchecked {\\n            uint mask = (256 ** (32 - len)) - 1;\\n            assembly {\\n                let srcpart := and(mload(src), not(mask))\\n                let destpart := and(mload(dest), mask)\\n                mstore(dest, or(destpart, srcpart))\\n            }\\n        }\\n\\n        return buf;\\n    }\\n\\n    /**\\n    * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\\n    *      the capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param data The data to append.\\n    * @param len The number of bytes to copy.\\n    * @return The original buffer, for chaining.\\n    */\\n    function append(buffer memory buf, bytes memory data, uint len) internal pure returns (buffer memory) {\\n        return write(buf, buf.buf.length, data, len);\\n    }\\n\\n    /**\\n    * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\\n    *      the capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param data The data to append.\\n    * @return The original buffer, for chaining.\\n    */\\n    function append(buffer memory buf, bytes memory data) internal pure returns (buffer memory) {\\n        return write(buf, buf.buf.length, data, data.length);\\n    }\\n\\n    /**\\n    * @dev Writes a byte to the buffer. Resizes if doing so would exceed the\\n    *      capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param off The offset to write the byte at.\\n    * @param data The data to append.\\n    * @return The original buffer, for chaining.\\n    */\\n    function writeUint8(buffer memory buf, uint off, uint8 data) internal pure returns(buffer memory) {\\n        if (off >= buf.capacity) {\\n            resize(buf, buf.capacity * 2);\\n        }\\n\\n        assembly {\\n            // Memory address of the buffer data\\n            let bufptr := mload(buf)\\n            // Length of existing buffer data\\n            let buflen := mload(bufptr)\\n            // Address = buffer address + sizeof(buffer length) + off\\n            let dest := add(add(bufptr, off), 32)\\n            mstore8(dest, data)\\n            // Update buffer length if we extended it\\n            if eq(off, buflen) {\\n                mstore(bufptr, add(buflen, 1))\\n            }\\n        }\\n        return buf;\\n    }\\n\\n    /**\\n    * @dev Appends a byte to the buffer. Resizes if doing so would exceed the\\n    *      capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param data The data to append.\\n    * @return The original buffer, for chaining.\\n    */\\n    function appendUint8(buffer memory buf, uint8 data) internal pure returns(buffer memory) {\\n        return writeUint8(buf, buf.buf.length, data);\\n    }\\n\\n    /**\\n    * @dev Writes up to 32 bytes to the buffer. Resizes if doing so would\\n    *      exceed the capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param off The offset to write at.\\n    * @param data The data to append.\\n    * @param len The number of bytes to write (left-aligned).\\n    * @return The original buffer, for chaining.\\n    */\\n    function write(buffer memory buf, uint off, bytes32 data, uint len) private pure returns(buffer memory) {\\n        if (len + off > buf.capacity) {\\n            resize(buf, (len + off) * 2);\\n        }\\n\\n        unchecked {\\n            uint mask = (256 ** len) - 1;\\n            // Right-align data\\n            data = data >> (8 * (32 - len));\\n            assembly {\\n                // Memory address of the buffer data\\n                let bufptr := mload(buf)\\n                // Address = buffer address + sizeof(buffer length) + off + len\\n                let dest := add(add(bufptr, off), len)\\n                mstore(dest, or(and(mload(dest), not(mask)), data))\\n                // Update buffer length if we extended it\\n                if gt(add(off, len), mload(bufptr)) {\\n                    mstore(bufptr, add(off, len))\\n                }\\n            }\\n        }\\n        return buf;\\n    }\\n\\n    /**\\n    * @dev Writes a bytes20 to the buffer. Resizes if doing so would exceed the\\n    *      capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param off The offset to write at.\\n    * @param data The data to append.\\n    * @return The original buffer, for chaining.\\n    */\\n    function writeBytes20(buffer memory buf, uint off, bytes20 data) internal pure returns (buffer memory) {\\n        return write(buf, off, bytes32(data), 20);\\n    }\\n\\n    /**\\n    * @dev Appends a bytes20 to the buffer. Resizes if doing so would exceed\\n    *      the capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param data The data to append.\\n    * @return The original buffer, for chhaining.\\n    */\\n    function appendBytes20(buffer memory buf, bytes20 data) internal pure returns (buffer memory) {\\n        return write(buf, buf.buf.length, bytes32(data), 20);\\n    }\\n\\n    /**\\n    * @dev Appends a bytes32 to the buffer. Resizes if doing so would exceed\\n    *      the capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param data The data to append.\\n    * @return The original buffer, for chaining.\\n    */\\n    function appendBytes32(buffer memory buf, bytes32 data) internal pure returns (buffer memory) {\\n        return write(buf, buf.buf.length, data, 32);\\n    }\\n\\n    /**\\n    * @dev Writes an integer to the buffer. Resizes if doing so would exceed\\n    *      the capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param off The offset to write at.\\n    * @param data The data to append.\\n    * @param len The number of bytes to write (right-aligned).\\n    * @return The original buffer, for chaining.\\n    */\\n    function writeInt(buffer memory buf, uint off, uint data, uint len) private pure returns(buffer memory) {\\n        if (len + off > buf.capacity) {\\n            resize(buf, (len + off) * 2);\\n        }\\n\\n        uint mask = (256 ** len) - 1;\\n        assembly {\\n            // Memory address of the buffer data\\n            let bufptr := mload(buf)\\n            // Address = buffer address + off + sizeof(buffer length) + len\\n            let dest := add(add(bufptr, off), len)\\n            mstore(dest, or(and(mload(dest), not(mask)), data))\\n            // Update buffer length if we extended it\\n            if gt(add(off, len), mload(bufptr)) {\\n                mstore(bufptr, add(off, len))\\n            }\\n        }\\n        return buf;\\n    }\\n\\n    /**\\n     * @dev Appends a byte to the end of the buffer. Resizes if doing so would\\n     * exceed the capacity of the buffer.\\n     * @param buf The buffer to append to.\\n     * @param data The data to append.\\n     * @return The original buffer.\\n     */\\n    function appendInt(buffer memory buf, uint data, uint len) internal pure returns(buffer memory) {\\n        return writeInt(buf, buf.buf.length, data, len);\\n    }\\n}\\n\",\"keccak256\":\"0x18e42be1a3e4f7b4442d7ab0b524af5e09163503439954faf0ab3792cce91caa\"},\"@ensdomains/ens-contracts/contracts/dnssec-oracle/BytesUtils.sol\":{\"content\":\"pragma solidity ^0.8.4;\\n\\nlibrary BytesUtils {\\n    /*\\n    * @dev Returns the keccak-256 hash of a byte range.\\n    * @param self The byte string to hash.\\n    * @param offset The position to start hashing at.\\n    * @param len The number of bytes to hash.\\n    * @return The hash of the byte range.\\n    */\\n    function keccak(bytes memory self, uint offset, uint len) internal pure returns (bytes32 ret) {\\n        require(offset + len <= self.length);\\n        assembly {\\n            ret := keccak256(add(add(self, 32), offset), len)\\n        }\\n    }\\n\\n\\n    /*\\n    * @dev Returns a positive number if `other` comes lexicographically after\\n    *      `self`, a negative number if it comes before, or zero if the\\n    *      contents of the two bytes are equal.\\n    * @param self The first bytes to compare.\\n    * @param other The second bytes to compare.\\n    * @return The result of the comparison.\\n    */\\n    function compare(bytes memory self, bytes memory other) internal pure returns (int) {\\n        return compare(self, 0, self.length, other, 0, other.length);\\n    }\\n\\n    /*\\n    * @dev Returns a positive number if `other` comes lexicographically after\\n    *      `self`, a negative number if it comes before, or zero if the\\n    *      contents of the two bytes are equal. Comparison is done per-rune,\\n    *      on unicode codepoints.\\n    * @param self The first bytes to compare.\\n    * @param offset The offset of self.\\n    * @param len    The length of self.\\n    * @param other The second bytes to compare.\\n    * @param otheroffset The offset of the other string.\\n    * @param otherlen    The length of the other string.\\n    * @return The result of the comparison.\\n    */\\n    function compare(bytes memory self, uint offset, uint len, bytes memory other, uint otheroffset, uint otherlen) internal pure returns (int) {\\n        uint shortest = len;\\n        if (otherlen < len)\\n        shortest = otherlen;\\n\\n        uint selfptr;\\n        uint otherptr;\\n\\n        assembly {\\n            selfptr := add(self, add(offset, 32))\\n            otherptr := add(other, add(otheroffset, 32))\\n        }\\n        for (uint idx = 0; idx < shortest; idx += 32) {\\n            uint a;\\n            uint b;\\n            assembly {\\n                a := mload(selfptr)\\n                b := mload(otherptr)\\n            }\\n            if (a != b) {\\n                // Mask out irrelevant bytes and check again\\n                uint mask;\\n                if (shortest > 32) {\\n                    mask = type(uint256).max;\\n                } else {\\n                    mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);\\n                }\\n                int diff = int(a & mask) - int(b & mask);\\n                if (diff != 0)\\n                return diff;\\n            }\\n            selfptr += 32;\\n            otherptr += 32;\\n        }\\n\\n        return int(len) - int(otherlen);\\n    }\\n\\n    /*\\n    * @dev Returns true if the two byte ranges are equal.\\n    * @param self The first byte range to compare.\\n    * @param offset The offset into the first byte range.\\n    * @param other The second byte range to compare.\\n    * @param otherOffset The offset into the second byte range.\\n    * @param len The number of bytes to compare\\n    * @return True if the byte ranges are equal, false otherwise.\\n    */\\n    function equals(bytes memory self, uint offset, bytes memory other, uint otherOffset, uint len) internal pure returns (bool) {\\n        return keccak(self, offset, len) == keccak(other, otherOffset, len);\\n    }\\n\\n    /*\\n    * @dev Returns true if the two byte ranges are equal with offsets.\\n    * @param self The first byte range to compare.\\n    * @param offset The offset into the first byte range.\\n    * @param other The second byte range to compare.\\n    * @param otherOffset The offset into the second byte range.\\n    * @return True if the byte ranges are equal, false otherwise.\\n    */\\n    function equals(bytes memory self, uint offset, bytes memory other, uint otherOffset) internal pure returns (bool) {\\n        return keccak(self, offset, self.length - offset) == keccak(other, otherOffset, other.length - otherOffset);\\n    }\\n\\n    /*\\n    * @dev Compares a range of 'self' to all of 'other' and returns True iff\\n    *      they are equal.\\n    * @param self The first byte range to compare.\\n    * @param offset The offset into the first byte range.\\n    * @param other The second byte range to compare.\\n    * @return True if the byte ranges are equal, false otherwise.\\n    */\\n    function equals(bytes memory self, uint offset, bytes memory other) internal pure returns (bool) {\\n        return self.length >= offset + other.length && equals(self, offset, other, 0, other.length);\\n    }\\n\\n    /*\\n    * @dev Returns true if the two byte ranges are equal.\\n    * @param self The first byte range to compare.\\n    * @param other The second byte range to compare.\\n    * @return True if the byte ranges are equal, false otherwise.\\n    */\\n    function equals(bytes memory self, bytes memory other) internal pure returns(bool) {\\n        return self.length == other.length && equals(self, 0, other, 0, self.length);\\n    }\\n\\n    /*\\n    * @dev Returns the 8-bit number at the specified index of self.\\n    * @param self The byte string.\\n    * @param idx The index into the bytes\\n    * @return The specified 8 bits of the string, interpreted as an integer.\\n    */\\n    function readUint8(bytes memory self, uint idx) internal pure returns (uint8 ret) {\\n        return uint8(self[idx]);\\n    }\\n\\n    /*\\n    * @dev Returns the 16-bit number at the specified index of self.\\n    * @param self The byte string.\\n    * @param idx The index into the bytes\\n    * @return The specified 16 bits of the string, interpreted as an integer.\\n    */\\n    function readUint16(bytes memory self, uint idx) internal pure returns (uint16 ret) {\\n        require(idx + 2 <= self.length);\\n        assembly {\\n            ret := and(mload(add(add(self, 2), idx)), 0xFFFF)\\n        }\\n    }\\n\\n    /*\\n    * @dev Returns the 32-bit number at the specified index of self.\\n    * @param self The byte string.\\n    * @param idx The index into the bytes\\n    * @return The specified 32 bits of the string, interpreted as an integer.\\n    */\\n    function readUint32(bytes memory self, uint idx) internal pure returns (uint32 ret) {\\n        require(idx + 4 <= self.length);\\n        assembly {\\n            ret := and(mload(add(add(self, 4), idx)), 0xFFFFFFFF)\\n        }\\n    }\\n\\n    /*\\n    * @dev Returns the 32 byte value at the specified index of self.\\n    * @param self The byte string.\\n    * @param idx The index into the bytes\\n    * @return The specified 32 bytes of the string.\\n    */\\n    function readBytes32(bytes memory self, uint idx) internal pure returns (bytes32 ret) {\\n        require(idx + 32 <= self.length);\\n        assembly {\\n            ret := mload(add(add(self, 32), idx))\\n        }\\n    }\\n\\n    /*\\n    * @dev Returns the 32 byte value at the specified index of self.\\n    * @param self The byte string.\\n    * @param idx The index into the bytes\\n    * @return The specified 32 bytes of the string.\\n    */\\n    function readBytes20(bytes memory self, uint idx) internal pure returns (bytes20 ret) {\\n        require(idx + 20 <= self.length);\\n        assembly {\\n            ret := and(mload(add(add(self, 32), idx)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000000)\\n        }\\n    }\\n\\n    /*\\n    * @dev Returns the n byte value at the specified index of self.\\n    * @param self The byte string.\\n    * @param idx The index into the bytes.\\n    * @param len The number of bytes.\\n    * @return The specified 32 bytes of the string.\\n    */\\n    function readBytesN(bytes memory self, uint idx, uint len) internal pure returns (bytes32 ret) {\\n        require(len <= 32);\\n        require(idx + len <= self.length);\\n        assembly {\\n            let mask := not(sub(exp(256, sub(32, len)), 1))\\n            ret := and(mload(add(add(self, 32), idx)),  mask)\\n        }\\n    }\\n\\n    function memcpy(uint dest, uint src, uint len) private pure {\\n        // Copy word-length chunks while possible\\n        for (; len >= 32; len -= 32) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n            dest += 32;\\n            src += 32;\\n        }\\n\\n        // Copy remaining bytes\\n        unchecked {\\n            uint mask = (256 ** (32 - len)) - 1;\\n            assembly {\\n                let srcpart := and(mload(src), not(mask))\\n                let destpart := and(mload(dest), mask)\\n                mstore(dest, or(destpart, srcpart))\\n            }\\n        }\\n    }\\n\\n    /*\\n    * @dev Copies a substring into a new byte string.\\n    * @param self The byte string to copy from.\\n    * @param offset The offset to start copying at.\\n    * @param len The number of bytes to copy.\\n    */\\n    function substring(bytes memory self, uint offset, uint len) internal pure returns(bytes memory) {\\n        require(offset + len <= self.length);\\n\\n        bytes memory ret = new bytes(len);\\n        uint dest;\\n        uint src;\\n\\n        assembly {\\n            dest := add(ret, 32)\\n            src := add(add(self, 32), offset)\\n        }\\n        memcpy(dest, src, len);\\n\\n        return ret;\\n    }\\n\\n    // Maps characters from 0x30 to 0x7A to their base32 values.\\n    // 0xFF represents invalid characters in that range.\\n    bytes constant base32HexTable = hex'00010203040506070809FFFFFFFFFFFFFF0A0B0C0D0E0F101112131415161718191A1B1C1D1E1FFFFFFFFFFFFFFFFFFFFF0A0B0C0D0E0F101112131415161718191A1B1C1D1E1F';\\n\\n    /**\\n     * @dev Decodes unpadded base32 data of up to one word in length.\\n     * @param self The data to decode.\\n     * @param off Offset into the string to start at.\\n     * @param len Number of characters to decode.\\n     * @return The decoded data, left aligned.\\n     */\\n    function base32HexDecodeWord(bytes memory self, uint off, uint len) internal pure returns(bytes32) {\\n        require(len <= 52);\\n\\n        uint ret = 0;\\n        uint8 decoded;\\n        for(uint i = 0; i < len; i++) {\\n            bytes1 char = self[off + i];\\n            require(char >= 0x30 && char <= 0x7A);\\n            decoded = uint8(base32HexTable[uint(uint8(char)) - 0x30]);\\n            require(decoded <= 0x20);\\n            if(i == len - 1) {\\n                break;\\n            }\\n            ret = (ret << 5) | decoded;\\n        }\\n\\n        uint bitlen = len * 5;\\n        if(len % 8 == 0) {\\n            // Multiple of 8 characters, no padding\\n            ret = (ret << 5) | decoded;\\n        } else if(len % 8 == 2) {\\n            // Two extra characters - 1 byte\\n            ret = (ret << 3) | (decoded >> 2);\\n            bitlen -= 2;\\n        } else if(len % 8 == 4) {\\n            // Four extra characters - 2 bytes\\n            ret = (ret << 1) | (decoded >> 4);\\n            bitlen -= 4;\\n        } else if(len % 8 == 5) {\\n            // Five extra characters - 3 bytes\\n            ret = (ret << 4) | (decoded >> 1);\\n            bitlen -= 1;\\n        } else if(len % 8 == 7) {\\n            // Seven extra characters - 4 bytes\\n            ret = (ret << 2) | (decoded >> 3);\\n            bitlen -= 3;\\n        } else {\\n            revert();\\n        }\\n\\n        return bytes32(ret << (256 - bitlen));\\n    }\\n}\",\"keccak256\":\"0x83315df2e54c74451577c70da2c267c3459802b08b9aeec6516302eee70f796e\"},\"@ensdomains/ens-contracts/contracts/dnssec-oracle/RRUtils.sol\":{\"content\":\"pragma solidity ^0.8.4;\\n\\nimport \\\"./BytesUtils.sol\\\";\\nimport \\\"@ensdomains/buffer/contracts/Buffer.sol\\\";\\n\\n/**\\n* @dev RRUtils is a library that provides utilities for parsing DNS resource records.\\n*/\\nlibrary RRUtils {\\n    using BytesUtils for *;\\n    using Buffer for *;\\n\\n    /**\\n    * @dev Returns the number of bytes in the DNS name at 'offset' in 'self'.\\n    * @param self The byte array to read a name from.\\n    * @param offset The offset to start reading at.\\n    * @return The length of the DNS name at 'offset', in bytes.\\n    */\\n    function nameLength(bytes memory self, uint offset) internal pure returns(uint) {\\n        uint idx = offset;\\n        while (true) {\\n            assert(idx < self.length);\\n            uint labelLen = self.readUint8(idx);\\n            idx += labelLen + 1;\\n            if (labelLen == 0) {\\n                break;\\n            }\\n        }\\n        return idx - offset;\\n    }\\n\\n    /**\\n    * @dev Returns a DNS format name at the specified offset of self.\\n    * @param self The byte array to read a name from.\\n    * @param offset The offset to start reading at.\\n    * @return ret The name.\\n    */\\n    function readName(bytes memory self, uint offset) internal pure returns(bytes memory ret) {\\n        uint len = nameLength(self, offset);\\n        return self.substring(offset, len);\\n    }\\n\\n    /**\\n    * @dev Returns the number of labels in the DNS name at 'offset' in 'self'.\\n    * @param self The byte array to read a name from.\\n    * @param offset The offset to start reading at.\\n    * @return The number of labels in the DNS name at 'offset', in bytes.\\n    */\\n    function labelCount(bytes memory self, uint offset) internal pure returns(uint) {\\n        uint count = 0;\\n        while (true) {\\n            assert(offset < self.length);\\n            uint labelLen = self.readUint8(offset);\\n            offset += labelLen + 1;\\n            if (labelLen == 0) {\\n                break;\\n            }\\n            count += 1;\\n        }\\n        return count;\\n    }\\n\\n    uint constant RRSIG_TYPE = 0;\\n    uint constant RRSIG_ALGORITHM = 2;\\n    uint constant RRSIG_LABELS = 3;\\n    uint constant RRSIG_TTL = 4;\\n    uint constant RRSIG_EXPIRATION = 8;\\n    uint constant RRSIG_INCEPTION = 12;\\n    uint constant RRSIG_KEY_TAG = 16;\\n    uint constant RRSIG_SIGNER_NAME = 18;\\n\\n    struct SignedSet {\\n        uint16 typeCovered;\\n        uint8 algorithm;\\n        uint8 labels;\\n        uint32 ttl;\\n        uint32 expiration;\\n        uint32 inception;\\n        uint16 keytag;\\n        bytes signerName;\\n        bytes data;\\n        bytes name;\\n    }\\n\\n    function readSignedSet(bytes memory data) internal pure returns(SignedSet memory self) {\\n        self.typeCovered = data.readUint16(RRSIG_TYPE);\\n        self.algorithm = data.readUint8(RRSIG_ALGORITHM);\\n        self.labels = data.readUint8(RRSIG_LABELS);\\n        self.ttl = data.readUint32(RRSIG_TTL);\\n        self.expiration = data.readUint32(RRSIG_EXPIRATION);\\n        self.inception = data.readUint32(RRSIG_INCEPTION);\\n        self.keytag = data.readUint16(RRSIG_KEY_TAG);\\n        self.signerName = readName(data, RRSIG_SIGNER_NAME);\\n        self.data = data.substring(RRSIG_SIGNER_NAME + self.signerName.length, data.length - RRSIG_SIGNER_NAME - self.signerName.length);\\n    }\\n\\n    function rrs(SignedSet memory rrset) internal pure returns(RRIterator memory) {\\n        return iterateRRs(rrset.data, 0);\\n    }\\n\\n    /**\\n    * @dev An iterator over resource records.\\n    */\\n    struct RRIterator {\\n        bytes data;\\n        uint offset;\\n        uint16 dnstype;\\n        uint16 class;\\n        uint32 ttl;\\n        uint rdataOffset;\\n        uint nextOffset;\\n    }\\n\\n    /**\\n    * @dev Begins iterating over resource records.\\n    * @param self The byte string to read from.\\n    * @param offset The offset to start reading at.\\n    * @return ret An iterator object.\\n    */\\n    function iterateRRs(bytes memory self, uint offset) internal pure returns (RRIterator memory ret) {\\n        ret.data = self;\\n        ret.nextOffset = offset;\\n        next(ret);\\n    }\\n\\n    /**\\n    * @dev Returns true iff there are more RRs to iterate.\\n    * @param iter The iterator to check.\\n    * @return True iff the iterator has finished.\\n    */\\n    function done(RRIterator memory iter) internal pure returns(bool) {\\n        return iter.offset >= iter.data.length;\\n    }\\n\\n    /**\\n    * @dev Moves the iterator to the next resource record.\\n    * @param iter The iterator to advance.\\n    */\\n    function next(RRIterator memory iter) internal pure {\\n        iter.offset = iter.nextOffset;\\n        if (iter.offset >= iter.data.length) {\\n            return;\\n        }\\n\\n        // Skip the name\\n        uint off = iter.offset + nameLength(iter.data, iter.offset);\\n\\n        // Read type, class, and ttl\\n        iter.dnstype = iter.data.readUint16(off);\\n        off += 2;\\n        iter.class = iter.data.readUint16(off);\\n        off += 2;\\n        iter.ttl = iter.data.readUint32(off);\\n        off += 4;\\n\\n        // Read the rdata\\n        uint rdataLength = iter.data.readUint16(off);\\n        off += 2;\\n        iter.rdataOffset = off;\\n        iter.nextOffset = off + rdataLength;\\n    }\\n\\n    /**\\n    * @dev Returns the name of the current record.\\n    * @param iter The iterator.\\n    * @return A new bytes object containing the owner name from the RR.\\n    */\\n    function name(RRIterator memory iter) internal pure returns(bytes memory) {\\n        return iter.data.substring(iter.offset, nameLength(iter.data, iter.offset));\\n    }\\n\\n    /**\\n    * @dev Returns the rdata portion of the current record.\\n    * @param iter The iterator.\\n    * @return A new bytes object containing the RR's RDATA.\\n    */\\n    function rdata(RRIterator memory iter) internal pure returns(bytes memory) {\\n        return iter.data.substring(iter.rdataOffset, iter.nextOffset - iter.rdataOffset);\\n    }\\n\\n    uint constant DNSKEY_FLAGS = 0;\\n    uint constant DNSKEY_PROTOCOL = 2;\\n    uint constant DNSKEY_ALGORITHM = 3;\\n    uint constant DNSKEY_PUBKEY = 4;\\n\\n    struct DNSKEY {\\n        uint16 flags;\\n        uint8 protocol;\\n        uint8 algorithm;\\n        bytes publicKey;\\n    }\\n\\n    function readDNSKEY(bytes memory data, uint offset, uint length) internal pure returns(DNSKEY memory self) {\\n        self.flags = data.readUint16(offset + DNSKEY_FLAGS);\\n        self.protocol = data.readUint8(offset + DNSKEY_PROTOCOL);\\n        self.algorithm = data.readUint8(offset + DNSKEY_ALGORITHM);\\n        self.publicKey = data.substring(offset + DNSKEY_PUBKEY, length - DNSKEY_PUBKEY);\\n    } \\n\\n    uint constant DS_KEY_TAG = 0;\\n    uint constant DS_ALGORITHM = 2;\\n    uint constant DS_DIGEST_TYPE = 3;\\n    uint constant DS_DIGEST = 4;\\n\\n    struct DS {\\n        uint16 keytag;\\n        uint8 algorithm;\\n        uint8 digestType;\\n        bytes digest;\\n    }\\n\\n    function readDS(bytes memory data, uint offset, uint length) internal pure returns(DS memory self) {\\n        self.keytag = data.readUint16(offset + DS_KEY_TAG);\\n        self.algorithm = data.readUint8(offset + DS_ALGORITHM);\\n        self.digestType = data.readUint8(offset + DS_DIGEST_TYPE);\\n        self.digest = data.substring(offset + DS_DIGEST, length - DS_DIGEST);\\n    }\\n\\n    struct NSEC3 {\\n        uint8 hashAlgorithm;\\n        uint8 flags;\\n        uint16 iterations;\\n        bytes salt;\\n        bytes32 nextHashedOwnerName;\\n        bytes typeBitmap;\\n    }\\n\\n    uint constant NSEC3_HASH_ALGORITHM = 0;\\n    uint constant NSEC3_FLAGS = 1;\\n    uint constant NSEC3_ITERATIONS = 2;\\n    uint constant NSEC3_SALT_LENGTH = 4;\\n    uint constant NSEC3_SALT = 5;\\n\\n    function readNSEC3(bytes memory data, uint offset, uint length) internal pure returns(NSEC3 memory self) {\\n        uint end = offset + length;\\n        self.hashAlgorithm = data.readUint8(offset + NSEC3_HASH_ALGORITHM);\\n        self.flags = data.readUint8(offset + NSEC3_FLAGS);\\n        self.iterations = data.readUint16(offset + NSEC3_ITERATIONS);\\n        uint8 saltLength = data.readUint8(offset + NSEC3_SALT_LENGTH);\\n        offset = offset + NSEC3_SALT;\\n        self.salt = data.substring(offset, saltLength);\\n        offset += saltLength;\\n        uint8 nextLength = data.readUint8(offset);\\n        require(nextLength <= 32);\\n        offset += 1;\\n        self.nextHashedOwnerName = data.readBytesN(offset, nextLength);\\n        offset += nextLength;\\n        self.typeBitmap = data.substring(offset, end - offset);\\n    }\\n\\n    function checkTypeBitmap(NSEC3 memory self, uint16 rrtype) internal pure returns(bool) {\\n        return checkTypeBitmap(self.typeBitmap, 0, rrtype);\\n    }\\n\\n    /**\\n    * @dev Checks if a given RR type exists in a type bitmap.\\n    * @param bitmap The byte string to read the type bitmap from.\\n    * @param offset The offset to start reading at.\\n    * @param rrtype The RR type to check for.\\n    * @return True if the type is found in the bitmap, false otherwise.\\n    */\\n    function checkTypeBitmap(bytes memory bitmap, uint offset, uint16 rrtype) internal pure returns (bool) {\\n        uint8 typeWindow = uint8(rrtype >> 8);\\n        uint8 windowByte = uint8((rrtype & 0xff) / 8);\\n        uint8 windowBitmask = uint8(uint8(1) << (uint8(7) - uint8(rrtype & 0x7)));\\n        for (uint off = offset; off < bitmap.length;) {\\n            uint8 window = bitmap.readUint8(off);\\n            uint8 len = bitmap.readUint8(off + 1);\\n            if (typeWindow < window) {\\n                // We've gone past our window; it's not here.\\n                return false;\\n            } else if (typeWindow == window) {\\n                // Check this type bitmap\\n                if (len <= windowByte) {\\n                    // Our type is past the end of the bitmap\\n                    return false;\\n                }\\n                return (bitmap.readUint8(off + windowByte + 2) & windowBitmask) != 0;\\n            } else {\\n                // Skip this type bitmap\\n                off += len + 2;\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    function compareNames(bytes memory self, bytes memory other) internal pure returns (int) {\\n        if (self.equals(other)) {\\n            return 0;\\n        }\\n\\n        uint off;\\n        uint otheroff;\\n        uint prevoff;\\n        uint otherprevoff;\\n        uint counts = labelCount(self, 0);\\n        uint othercounts = labelCount(other, 0);\\n\\n        // Keep removing labels from the front of the name until both names are equal length\\n        while (counts > othercounts) {\\n            prevoff = off;\\n            off = progress(self, off);\\n            counts--;\\n        }\\n\\n        while (othercounts > counts) {\\n            otherprevoff = otheroff;\\n            otheroff = progress(other, otheroff);\\n            othercounts--;\\n        }\\n\\n        // Compare the last nonequal labels to each other\\n        while (counts > 0 && !self.equals(off, other, otheroff)) {\\n            prevoff = off;\\n            off = progress(self, off);\\n            otherprevoff = otheroff;\\n            otheroff = progress(other, otheroff);\\n            counts -= 1;\\n        }\\n\\n        if (off == 0) {\\n            return -1;\\n        }\\n        if(otheroff == 0) {\\n            return 1;\\n        }\\n\\n        return self.compare(prevoff + 1, self.readUint8(prevoff), other, otherprevoff + 1, other.readUint8(otherprevoff));\\n    }\\n\\n    /**\\n     * @dev Compares two serial numbers using RFC1982 serial number math.\\n     */\\n    function serialNumberGte(uint32 i1, uint32 i2) internal pure returns(bool) {\\n        return int32(i1) - int32(i2) >= 0;\\n    }\\n\\n    function progress(bytes memory body, uint off) internal pure returns(uint) {\\n        return off + 1 + body.readUint8(off);\\n    }\\n}\",\"keccak256\":\"0x021cc7832a603e41b94d38eced8175452eaa5ab4794376fa3f722362844aeefe\"},\"@ensdomains/ens-contracts/contracts/registry/ENS.sol\":{\"content\":\"pragma solidity >=0.8.4;\\n\\ninterface ENS {\\n\\n    // Logged when the owner of a node assigns a new owner to a subnode.\\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\\n\\n    // Logged when the owner of a node transfers ownership to a new account.\\n    event Transfer(bytes32 indexed node, address owner);\\n\\n    // Logged when the resolver for a node changes.\\n    event NewResolver(bytes32 indexed node, address resolver);\\n\\n    // Logged when the TTL of a node changes\\n    event NewTTL(bytes32 indexed node, uint64 ttl);\\n\\n    // Logged when an operator is added or removed.\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    function setRecord(bytes32 node, address owner, address resolver, uint64 ttl) external virtual;\\n    function setSubnodeRecord(bytes32 node, bytes32 label, address owner, address resolver, uint64 ttl) external virtual;\\n    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) external virtual returns(bytes32);\\n    function setResolver(bytes32 node, address resolver) external virtual;\\n    function setOwner(bytes32 node, address owner) external virtual;\\n    function setTTL(bytes32 node, uint64 ttl) external virtual;\\n    function setApprovalForAll(address operator, bool approved) external virtual;\\n    function owner(bytes32 node) external virtual view returns (address);\\n    function resolver(bytes32 node) external virtual view returns (address);\\n    function ttl(bytes32 node) external virtual view returns (uint64);\\n    function recordExists(bytes32 node) external virtual view returns (bool);\\n    function isApprovedForAll(address owner, address operator) external virtual view returns (bool);\\n}\\n\",\"keccak256\":\"0x942ef29bd7c0f62228aeb91879ddd1ba101f52a2162970d3e48adffa498f4483\"},\"@ensdomains/ens-contracts/contracts/registry/ENSRegistry.sol\":{\"content\":\"pragma solidity >=0.8.4;\\n\\nimport \\\"./ENS.sol\\\";\\n\\n/**\\n * The ENS registry contract.\\n */\\ncontract ENSRegistry is ENS {\\n\\n    struct Record {\\n        address owner;\\n        address resolver;\\n        uint64 ttl;\\n    }\\n\\n    mapping (bytes32 => Record) records;\\n    mapping (address => mapping(address => bool)) operators;\\n\\n    // Permits modifications only by the owner of the specified node.\\n    modifier authorised(bytes32 node) {\\n        address owner = records[node].owner;\\n        require(owner == msg.sender || operators[owner][msg.sender]);\\n        _;\\n    }\\n\\n    /**\\n     * @dev Constructs a new ENS registrar.\\n     */\\n    constructor() public {\\n        records[0x0].owner = msg.sender;\\n    }\\n\\n    /**\\n     * @dev Sets the record for a node.\\n     * @param node The node to update.\\n     * @param owner The address of the new owner.\\n     * @param resolver The address of the resolver.\\n     * @param ttl The TTL in seconds.\\n     */\\n    function setRecord(bytes32 node, address owner, address resolver, uint64 ttl) external virtual override {\\n        setOwner(node, owner);\\n        _setResolverAndTTL(node, resolver, ttl);\\n    }\\n\\n    /**\\n     * @dev Sets the record for a subnode.\\n     * @param node The parent node.\\n     * @param label The hash of the label specifying the subnode.\\n     * @param owner The address of the new owner.\\n     * @param resolver The address of the resolver.\\n     * @param ttl The TTL in seconds.\\n     */\\n    function setSubnodeRecord(bytes32 node, bytes32 label, address owner, address resolver, uint64 ttl) external virtual override {\\n        bytes32 subnode = setSubnodeOwner(node, label, owner);\\n        _setResolverAndTTL(subnode, resolver, ttl);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of a node to a new address. May only be called by the current owner of the node.\\n     * @param node The node to transfer ownership of.\\n     * @param owner The address of the new owner.\\n     */\\n    function setOwner(bytes32 node, address owner) public virtual override authorised(node) {\\n        _setOwner(node, owner);\\n        emit Transfer(node, owner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of a subnode keccak256(node, label) to a new address. May only be called by the owner of the parent node.\\n     * @param node The parent node.\\n     * @param label The hash of the label specifying the subnode.\\n     * @param owner The address of the new owner.\\n     */\\n    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) public virtual override authorised(node) returns(bytes32) {\\n        bytes32 subnode = keccak256(abi.encodePacked(node, label));\\n        _setOwner(subnode, owner);\\n        emit NewOwner(node, label, owner);\\n        return subnode;\\n    }\\n\\n    /**\\n     * @dev Sets the resolver address for the specified node.\\n     * @param node The node to update.\\n     * @param resolver The address of the resolver.\\n     */\\n    function setResolver(bytes32 node, address resolver) public virtual override authorised(node) {\\n        emit NewResolver(node, resolver);\\n        records[node].resolver = resolver;\\n    }\\n\\n    /**\\n     * @dev Sets the TTL for the specified node.\\n     * @param node The node to update.\\n     * @param ttl The TTL in seconds.\\n     */\\n    function setTTL(bytes32 node, uint64 ttl) public virtual override authorised(node) {\\n        emit NewTTL(node, ttl);\\n        records[node].ttl = ttl;\\n    }\\n\\n    /**\\n     * @dev Enable or disable approval for a third party (\\\"operator\\\") to manage\\n     *  all of `msg.sender`'s ENS records. Emits the ApprovalForAll event.\\n     * @param operator Address to add to the set of authorized operators.\\n     * @param approved True if the operator is approved, false to revoke approval.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external virtual override {\\n        operators[msg.sender][operator] = approved;\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    /**\\n     * @dev Returns the address that owns the specified node.\\n     * @param node The specified node.\\n     * @return address of the owner.\\n     */\\n    function owner(bytes32 node) public virtual override view returns (address) {\\n        address addr = records[node].owner;\\n        if (addr == address(this)) {\\n            return address(0x0);\\n        }\\n\\n        return addr;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the resolver for the specified node.\\n     * @param node The specified node.\\n     * @return address of the resolver.\\n     */\\n    function resolver(bytes32 node) public virtual override view returns (address) {\\n        return records[node].resolver;\\n    }\\n\\n    /**\\n     * @dev Returns the TTL of a node, and any records associated with it.\\n     * @param node The specified node.\\n     * @return ttl of the node.\\n     */\\n    function ttl(bytes32 node) public virtual override view returns (uint64) {\\n        return records[node].ttl;\\n    }\\n\\n    /**\\n     * @dev Returns whether a record has been imported to the registry.\\n     * @param node The specified node.\\n     * @return Bool if record exists\\n     */\\n    function recordExists(bytes32 node) public virtual override view returns (bool) {\\n        return records[node].owner != address(0x0);\\n    }\\n\\n    /**\\n     * @dev Query if an address is an authorized operator for another address.\\n     * @param owner The address that owns the records.\\n     * @param operator The address that acts on behalf of the owner.\\n     * @return True if `operator` is an approved operator for `owner`, false otherwise.\\n     */\\n    function isApprovedForAll(address owner, address operator) external virtual override view returns (bool) {\\n        return operators[owner][operator];\\n    }\\n\\n    function _setOwner(bytes32 node, address owner) internal virtual {\\n        records[node].owner = owner;\\n    }\\n\\n    function _setResolverAndTTL(bytes32 node, address resolver, uint64 ttl) internal {\\n        if(resolver != records[node].resolver) {\\n            records[node].resolver = resolver;\\n            emit NewResolver(node, resolver);\\n        }\\n\\n        if(ttl != records[node].ttl) {\\n            records[node].ttl = ttl;\\n            emit NewTTL(node, ttl);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf025a2fa3fcf89a3db7064e85e9b618707a39cb47c9c1bfedaec5313b118a1c6\"},\"@ensdomains/ens-contracts/contracts/resolvers/PublicResolver.sol\":{\"content\":\"pragma solidity >=0.8.4;\\n\\nimport \\\"../registry/ENS.sol\\\";\\nimport \\\"./profiles/ABIResolver.sol\\\";\\nimport \\\"./profiles/AddrResolver.sol\\\";\\nimport \\\"./profiles/ContentHashResolver.sol\\\";\\nimport \\\"./profiles/DNSResolver.sol\\\";\\nimport \\\"./profiles/InterfaceResolver.sol\\\";\\nimport \\\"./profiles/NameResolver.sol\\\";\\nimport \\\"./profiles/PubkeyResolver.sol\\\";\\nimport \\\"./profiles/TextResolver.sol\\\";\\n\\ninterface INameWrapper {\\n    function ownerOf(uint256 id) external view returns (address);\\n}\\n\\n/**\\n * A simple resolver anyone can use; only allows the owner of a node to set its\\n * address.\\n */\\ncontract PublicResolver is ABIResolver, AddrResolver, ContentHashResolver, DNSResolver, InterfaceResolver, NameResolver, PubkeyResolver, TextResolver {\\n    ENS ens;\\n    INameWrapper nameWrapper;\\n\\n    /**\\n     * A mapping of operators. An address that is authorised for an address\\n     * may make any changes to the name that the owner could, but may not update\\n     * the set of authorisations.\\n     * (owner, operator) => approved\\n     */\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    // Logged when an operator is added or removed.\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    constructor(ENS _ens, INameWrapper wrapperAddress){\\n        ens = _ens;\\n        nameWrapper = wrapperAddress;\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external{\\n        require(\\n            msg.sender != operator,\\n            \\\"ERC1155: setting approval status for self\\\"\\n        );\\n\\n        _operatorApprovals[msg.sender][operator] = approved;\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function isAuthorised(bytes32 node) internal override view returns(bool) {\\n        address owner = ens.owner(node);\\n        if(owner == address(nameWrapper) ){\\n            owner = nameWrapper.ownerOf(uint256(node));\\n        }\\n        return owner == msg.sender || isApprovedForAll(owner, msg.sender);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) public view returns (bool){\\n        return _operatorApprovals[account][operator];\\n    }\\n\\n    function multicall(bytes[] calldata data) external returns(bytes[] memory results) {\\n        results = new bytes[](data.length);\\n        for(uint i = 0; i < data.length; i++) {\\n            (bool success, bytes memory result) = address(this).delegatecall(data[i]);\\n            require(success);\\n            results[i] = result;\\n        }\\n        return results;\\n    }\\n\\n    function supportsInterface(bytes4 interfaceID) virtual override(ABIResolver, AddrResolver, ContentHashResolver, DNSResolver, InterfaceResolver, NameResolver, PubkeyResolver, TextResolver) public pure returns(bool) {\\n        return super.supportsInterface(interfaceID);\\n    }\\n}\\n\",\"keccak256\":\"0x6798b8d8cfbe72bcf416321bf2a631cc3cf0a0e4b66001e0992af580ef198f30\"},\"@ensdomains/ens-contracts/contracts/resolvers/ResolverBase.sol\":{\"content\":\"pragma solidity >=0.8.4;\\nabstract contract ResolverBase {\\n    bytes4 private constant INTERFACE_META_ID = 0x01ffc9a7;\\n\\n    function supportsInterface(bytes4 interfaceID) virtual public pure returns(bool) {\\n        return interfaceID == INTERFACE_META_ID;\\n    }\\n\\n    function isAuthorised(bytes32 node) internal virtual view returns(bool);\\n\\n    modifier authorised(bytes32 node) {\\n        require(isAuthorised(node));\\n        _;\\n    }\\n\\n    function bytesToAddress(bytes memory b) internal pure returns(address payable a) {\\n        require(b.length == 20);\\n        assembly {\\n            a := div(mload(add(b, 32)), exp(256, 12))\\n        }\\n    }\\n\\n    function addressToBytes(address a) internal pure returns(bytes memory b) {\\n        b = new bytes(20);\\n        assembly {\\n            mstore(add(b, 32), mul(a, exp(256, 12)))\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x19ff93130a91ea54f949022dafa27cd9fa9af647820d957aed3c8641b1354d8e\"},\"@ensdomains/ens-contracts/contracts/resolvers/profiles/ABIResolver.sol\":{\"content\":\"pragma solidity >=0.8.4;\\nimport \\\"../ResolverBase.sol\\\";\\n\\nabstract contract ABIResolver is ResolverBase {\\n    bytes4 constant private ABI_INTERFACE_ID = 0x2203ab56;\\n\\n    event ABIChanged(bytes32 indexed node, uint256 indexed contentType);\\n\\n    mapping(bytes32=>mapping(uint256=>bytes)) abis;\\n\\n    /**\\n     * Sets the ABI associated with an ENS node.\\n     * Nodes may have one ABI of each content type. To remove an ABI, set it to\\n     * the empty string.\\n     * @param node The node to update.\\n     * @param contentType The content type of the ABI\\n     * @param data The ABI data.\\n     */\\n    function setABI(bytes32 node, uint256 contentType, bytes calldata data) external authorised(node) {\\n        // Content types must be powers of 2\\n        require(((contentType - 1) & contentType) == 0);\\n\\n        abis[node][contentType] = data;\\n        emit ABIChanged(node, contentType);\\n    }\\n\\n    /**\\n     * Returns the ABI associated with an ENS node.\\n     * Defined in EIP205.\\n     * @param node The ENS node to query\\n     * @param contentTypes A bitwise OR of the ABI formats accepted by the caller.\\n     * @return contentType The content type of the return value\\n     * @return data The ABI data\\n     */\\n    function ABI(bytes32 node, uint256 contentTypes) external view returns (uint256, bytes memory) {\\n        mapping(uint256=>bytes) storage abiset = abis[node];\\n\\n        for (uint256 contentType = 1; contentType <= contentTypes; contentType <<= 1) {\\n            if ((contentType & contentTypes) != 0 && abiset[contentType].length > 0) {\\n                return (contentType, abiset[contentType]);\\n            }\\n        }\\n\\n        return (0, bytes(\\\"\\\"));\\n    }\\n\\n    function supportsInterface(bytes4 interfaceID) virtual override public pure returns(bool) {\\n        return interfaceID == ABI_INTERFACE_ID || super.supportsInterface(interfaceID);\\n    }\\n}\\n\",\"keccak256\":\"0x371491a137dde6b09a7345f568539e8b4585fb30615d2192ceeeb46d82dc0935\"},\"@ensdomains/ens-contracts/contracts/resolvers/profiles/AddrResolver.sol\":{\"content\":\"pragma solidity >=0.8.4;\\nimport \\\"../ResolverBase.sol\\\";\\n\\nabstract contract AddrResolver is ResolverBase {\\n    bytes4 constant private ADDR_INTERFACE_ID = 0x3b3b57de;\\n    bytes4 constant private ADDRESS_INTERFACE_ID = 0xf1cb7e06;\\n    uint constant private COIN_TYPE_ETH = 60;\\n\\n    event AddrChanged(bytes32 indexed node, address a);\\n    event AddressChanged(bytes32 indexed node, uint coinType, bytes newAddress);\\n\\n    mapping(bytes32=>mapping(uint=>bytes)) _addresses;\\n\\n    /**\\n     * Sets the address associated with an ENS node.\\n     * May only be called by the owner of that node in the ENS registry.\\n     * @param node The node to update.\\n     * @param a The address to set.\\n     */\\n    function setAddr(bytes32 node, address a) external authorised(node) {\\n        setAddr(node, COIN_TYPE_ETH, addressToBytes(a));\\n    }\\n\\n    /**\\n     * Returns the address associated with an ENS node.\\n     * @param node The ENS node to query.\\n     * @return The associated address.\\n     */\\n    function addr(bytes32 node) public view returns (address payable) {\\n        bytes memory a = addr(node, COIN_TYPE_ETH);\\n        if(a.length == 0) {\\n            return payable(0);\\n        }\\n        return bytesToAddress(a);\\n    }\\n\\n    function setAddr(bytes32 node, uint coinType, bytes memory a) public authorised(node) {\\n        emit AddressChanged(node, coinType, a);\\n        if(coinType == COIN_TYPE_ETH) {\\n            emit AddrChanged(node, bytesToAddress(a));\\n        }\\n        _addresses[node][coinType] = a;\\n    }\\n\\n    function addr(bytes32 node, uint coinType) public view returns(bytes memory) {\\n        return _addresses[node][coinType];\\n    }\\n\\n    function supportsInterface(bytes4 interfaceID) virtual override public pure returns(bool) {\\n        return interfaceID == ADDR_INTERFACE_ID || interfaceID == ADDRESS_INTERFACE_ID || super.supportsInterface(interfaceID);\\n    }\\n}\\n\",\"keccak256\":\"0x5e32ad40c831931e1d1cba27622078fd8a838227ed23d2bba253e1256e8f331a\"},\"@ensdomains/ens-contracts/contracts/resolvers/profiles/ContentHashResolver.sol\":{\"content\":\"pragma solidity >=0.8.4;\\nimport \\\"../ResolverBase.sol\\\";\\n\\nabstract contract ContentHashResolver is ResolverBase {\\n    bytes4 constant private CONTENT_HASH_INTERFACE_ID = 0xbc1c58d1;\\n\\n    event ContenthashChanged(bytes32 indexed node, bytes hash);\\n\\n    mapping(bytes32=>bytes) hashes;\\n\\n    /**\\n     * Sets the contenthash associated with an ENS node.\\n     * May only be called by the owner of that node in the ENS registry.\\n     * @param node The node to update.\\n     * @param hash The contenthash to set\\n     */\\n    function setContenthash(bytes32 node, bytes calldata hash) external authorised(node) {\\n        hashes[node] = hash;\\n        emit ContenthashChanged(node, hash);\\n    }\\n\\n    /**\\n     * Returns the contenthash associated with an ENS node.\\n     * @param node The ENS node to query.\\n     * @return The associated contenthash.\\n     */\\n    function contenthash(bytes32 node) external view returns (bytes memory) {\\n        return hashes[node];\\n    }\\n\\n    function supportsInterface(bytes4 interfaceID) virtual override public pure returns(bool) {\\n        return interfaceID == CONTENT_HASH_INTERFACE_ID || super.supportsInterface(interfaceID);\\n    }\\n}\\n\",\"keccak256\":\"0x46f179cc9a316da02c1c568b6c701b42409c144116e56ea4534b642326379a6b\"},\"@ensdomains/ens-contracts/contracts/resolvers/profiles/DNSResolver.sol\":{\"content\":\"pragma solidity >=0.8.4;\\nimport \\\"../ResolverBase.sol\\\";\\nimport \\\"../../dnssec-oracle/RRUtils.sol\\\";\\n\\nabstract contract DNSResolver is ResolverBase {\\n    using RRUtils for *;\\n    using BytesUtils for bytes;\\n\\n    bytes4 constant private DNS_RECORD_INTERFACE_ID = 0xa8fa5682;\\n    bytes4 constant private DNS_ZONE_INTERFACE_ID = 0x5c47637c;\\n\\n    // DNSRecordChanged is emitted whenever a given node/name/resource's RRSET is updated.\\n    event DNSRecordChanged(bytes32 indexed node, bytes name, uint16 resource, bytes record);\\n    // DNSRecordDeleted is emitted whenever a given node/name/resource's RRSET is deleted.\\n    event DNSRecordDeleted(bytes32 indexed node, bytes name, uint16 resource);\\n    // DNSZoneCleared is emitted whenever a given node's zone information is cleared.\\n    event DNSZoneCleared(bytes32 indexed node);\\n\\n    // DNSZonehashChanged is emitted whenever a given node's zone hash is updated.\\n    event DNSZonehashChanged(bytes32 indexed node, bytes lastzonehash, bytes zonehash);\\n\\n    // Zone hashes for the domains.\\n    // A zone hash is an EIP-1577 content hash in binary format that should point to a\\n    // resource containing a single zonefile.\\n    // node => contenthash\\n    mapping(bytes32=>bytes) private zonehashes;\\n\\n    // Version the mapping for each zone.  This allows users who have lost\\n    // track of their entries to effectively delete an entire zone by bumping\\n    // the version number.\\n    // node => version\\n    mapping(bytes32=>uint256) private versions;\\n\\n    // The records themselves.  Stored as binary RRSETs\\n    // node => version => name => resource => data\\n    mapping(bytes32=>mapping(uint256=>mapping(bytes32=>mapping(uint16=>bytes)))) private records;\\n\\n    // Count of number of entries for a given name.  Required for DNS resolvers\\n    // when resolving wildcards.\\n    // node => version => name => number of records\\n    mapping(bytes32=>mapping(uint256=>mapping(bytes32=>uint16))) private nameEntriesCount;\\n\\n    /**\\n     * Set one or more DNS records.  Records are supplied in wire-format.\\n     * Records with the same node/name/resource must be supplied one after the\\n     * other to ensure the data is updated correctly. For example, if the data\\n     * was supplied:\\n     *     a.example.com IN A 1.2.3.4\\n     *     a.example.com IN A 5.6.7.8\\n     *     www.example.com IN CNAME a.example.com.\\n     * then this would store the two A records for a.example.com correctly as a\\n     * single RRSET, however if the data was supplied:\\n     *     a.example.com IN A 1.2.3.4\\n     *     www.example.com IN CNAME a.example.com.\\n     *     a.example.com IN A 5.6.7.8\\n     * then this would store the first A record, the CNAME, then the second A\\n     * record which would overwrite the first.\\n     *\\n     * @param node the namehash of the node for which to set the records\\n     * @param data the DNS wire format records to set\\n     */\\n    function setDNSRecords(bytes32 node, bytes calldata data) external authorised(node) {\\n        uint16 resource = 0;\\n        uint256 offset = 0;\\n        bytes memory name;\\n        bytes memory value;\\n        bytes32 nameHash;\\n        // Iterate over the data to add the resource records\\n        for (RRUtils.RRIterator memory iter = data.iterateRRs(0); !iter.done(); iter.next()) {\\n            if (resource == 0) {\\n                resource = iter.dnstype;\\n                name = iter.name();\\n                nameHash = keccak256(abi.encodePacked(name));\\n                value = bytes(iter.rdata());\\n            } else {\\n                bytes memory newName = iter.name();\\n                if (resource != iter.dnstype || !name.equals(newName)) {\\n                    setDNSRRSet(node, name, resource, data, offset, iter.offset - offset, value.length == 0);\\n                    resource = iter.dnstype;\\n                    offset = iter.offset;\\n                    name = newName;\\n                    nameHash = keccak256(name);\\n                    value = bytes(iter.rdata());\\n                }\\n            }\\n        }\\n        if (name.length > 0) {\\n            setDNSRRSet(node, name, resource, data, offset, data.length - offset, value.length == 0);\\n        }\\n    }\\n\\n    /**\\n     * Obtain a DNS record.\\n     * @param node the namehash of the node for which to fetch the record\\n     * @param name the keccak-256 hash of the fully-qualified name for which to fetch the record\\n     * @param resource the ID of the resource as per https://en.wikipedia.org/wiki/List_of_DNS_record_types\\n     * @return the DNS record in wire format if present, otherwise empty\\n     */\\n    function dnsRecord(bytes32 node, bytes32 name, uint16 resource) public view returns (bytes memory) {\\n        return records[node][versions[node]][name][resource];\\n    }\\n\\n    /**\\n     * Check if a given node has records.\\n     * @param node the namehash of the node for which to check the records\\n     * @param name the namehash of the node for which to check the records\\n     */\\n    function hasDNSRecords(bytes32 node, bytes32 name) public view returns (bool) {\\n        return (nameEntriesCount[node][versions[node]][name] != 0);\\n    }\\n\\n    /**\\n     * Clear all information for a DNS zone.\\n     * @param node the namehash of the node for which to clear the zone\\n     */\\n    function clearDNSZone(bytes32 node) public authorised(node) {\\n        versions[node]++;\\n        emit DNSZoneCleared(node);\\n    }\\n\\n    /**\\n     * setZonehash sets the hash for the zone.\\n     * May only be called by the owner of that node in the ENS registry.\\n     * @param node The node to update.\\n     * @param hash The zonehash to set\\n     */\\n    function setZonehash(bytes32 node, bytes calldata hash) external authorised(node) {\\n        bytes memory oldhash = zonehashes[node];\\n        zonehashes[node] = hash;\\n        emit DNSZonehashChanged(node, oldhash, hash);\\n    }\\n\\n    /**\\n     * zonehash obtains the hash for the zone.\\n     * @param node The ENS node to query.\\n     * @return The associated contenthash.\\n     */\\n    function zonehash(bytes32 node) external view returns (bytes memory) {\\n        return zonehashes[node];\\n    }\\n\\n    function supportsInterface(bytes4 interfaceID) virtual override public pure returns(bool) {\\n        return interfaceID == DNS_RECORD_INTERFACE_ID ||\\n               interfaceID == DNS_ZONE_INTERFACE_ID ||\\n               super.supportsInterface(interfaceID);\\n    }\\n\\n    function setDNSRRSet(\\n        bytes32 node,\\n        bytes memory name,\\n        uint16 resource,\\n        bytes memory data,\\n        uint256 offset,\\n        uint256 size,\\n        bool deleteRecord) private\\n    {\\n        uint256 version = versions[node];\\n        bytes32 nameHash = keccak256(name);\\n        bytes memory rrData = data.substring(offset, size);\\n        if (deleteRecord) {\\n            if (records[node][version][nameHash][resource].length != 0) {\\n                nameEntriesCount[node][version][nameHash]--;\\n            }\\n            delete(records[node][version][nameHash][resource]);\\n            emit DNSRecordDeleted(node, name, resource);\\n        } else {\\n            if (records[node][version][nameHash][resource].length == 0) {\\n                nameEntriesCount[node][version][nameHash]++;\\n            }\\n            records[node][version][nameHash][resource] = rrData;\\n            emit DNSRecordChanged(node, name, resource, rrData);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x4d74aef492a44a29ea8757a6148740413a8c8f1256ce8d4551c89bdc2d91e0b1\"},\"@ensdomains/ens-contracts/contracts/resolvers/profiles/InterfaceResolver.sol\":{\"content\":\"pragma solidity >=0.8.4;\\nimport \\\"../ResolverBase.sol\\\";\\nimport \\\"./AddrResolver.sol\\\";\\n\\nabstract contract InterfaceResolver is ResolverBase, AddrResolver {\\n    bytes4 constant private INTERFACE_INTERFACE_ID = bytes4(keccak256(\\\"interfaceImplementer(bytes32,bytes4)\\\"));\\n    bytes4 private constant INTERFACE_META_ID = 0x01ffc9a7;\\n\\n    event InterfaceChanged(bytes32 indexed node, bytes4 indexed interfaceID, address implementer);\\n\\n    mapping(bytes32=>mapping(bytes4=>address)) interfaces;\\n\\n    /**\\n     * Sets an interface associated with a name.\\n     * Setting the address to 0 restores the default behaviour of querying the contract at `addr()` for interface support.\\n     * @param node The node to update.\\n     * @param interfaceID The EIP 165 interface ID.\\n     * @param implementer The address of a contract that implements this interface for this node.\\n     */\\n    function setInterface(bytes32 node, bytes4 interfaceID, address implementer) external authorised(node) {\\n        interfaces[node][interfaceID] = implementer;\\n        emit InterfaceChanged(node, interfaceID, implementer);\\n    }\\n\\n    /**\\n     * Returns the address of a contract that implements the specified interface for this name.\\n     * If an implementer has not been set for this interfaceID and name, the resolver will query\\n     * the contract at `addr()`. If `addr()` is set, a contract exists at that address, and that\\n     * contract implements EIP165 and returns `true` for the specified interfaceID, its address\\n     * will be returned.\\n     * @param node The ENS node to query.\\n     * @param interfaceID The EIP 165 interface ID to check for.\\n     * @return The address that implements this interface, or 0 if the interface is unsupported.\\n     */\\n    function interfaceImplementer(bytes32 node, bytes4 interfaceID) external view returns (address) {\\n        address implementer = interfaces[node][interfaceID];\\n        if(implementer != address(0)) {\\n            return implementer;\\n        }\\n\\n        address a = addr(node);\\n        if(a == address(0)) {\\n            return address(0);\\n        }\\n\\n        (bool success, bytes memory returnData) = a.staticcall(abi.encodeWithSignature(\\\"supportsInterface(bytes4)\\\", INTERFACE_META_ID));\\n        if(!success || returnData.length < 32 || returnData[31] == 0) {\\n            // EIP 165 not supported by target\\n            return address(0);\\n        }\\n\\n        (success, returnData) = a.staticcall(abi.encodeWithSignature(\\\"supportsInterface(bytes4)\\\", interfaceID));\\n        if(!success || returnData.length < 32 || returnData[31] == 0) {\\n            // Specified interface not supported by target\\n            return address(0);\\n        }\\n\\n        return a;\\n    }\\n\\n    function supportsInterface(bytes4 interfaceID) virtual override(AddrResolver, ResolverBase) public pure returns(bool) {\\n        return interfaceID == INTERFACE_INTERFACE_ID || super.supportsInterface(interfaceID);\\n    }\\n}\\n\",\"keccak256\":\"0x4e06e3117df99a3f6ec7fb00ec542a78d31ffdb19bbaa96b2c96c339f23ae65b\"},\"@ensdomains/ens-contracts/contracts/resolvers/profiles/NameResolver.sol\":{\"content\":\"pragma solidity >=0.8.4;\\nimport \\\"../ResolverBase.sol\\\";\\n\\nabstract contract NameResolver is ResolverBase {\\n    bytes4 constant private NAME_INTERFACE_ID = 0x691f3431;\\n\\n    event NameChanged(bytes32 indexed node, string name);\\n\\n    mapping(bytes32=>string) names;\\n\\n    /**\\n     * Sets the name associated with an ENS node, for reverse records.\\n     * May only be called by the owner of that node in the ENS registry.\\n     * @param node The node to update.\\n     * @param name The name to set.\\n     */\\n    function setName(bytes32 node, string calldata name) external authorised(node) {\\n        names[node] = name;\\n        emit NameChanged(node, name);\\n    }\\n\\n    /**\\n     * Returns the name associated with an ENS node, for reverse records.\\n     * Defined in EIP181.\\n     * @param node The ENS node to query.\\n     * @return The associated name.\\n     */\\n    function name(bytes32 node) external view returns (string memory) {\\n        return names[node];\\n    }\\n\\n    function supportsInterface(bytes4 interfaceID) virtual override public pure returns(bool) {\\n        return interfaceID == NAME_INTERFACE_ID || super.supportsInterface(interfaceID);\\n    }\\n}\\n\",\"keccak256\":\"0x49a44703212e1f5770fbe57dfa2d36806417eb74796af6956b25cbb6121f3f61\"},\"@ensdomains/ens-contracts/contracts/resolvers/profiles/PubkeyResolver.sol\":{\"content\":\"pragma solidity >=0.8.4;\\nimport \\\"../ResolverBase.sol\\\";\\n\\nabstract contract PubkeyResolver is ResolverBase {\\n    bytes4 constant private PUBKEY_INTERFACE_ID = 0xc8690233;\\n\\n    event PubkeyChanged(bytes32 indexed node, bytes32 x, bytes32 y);\\n\\n    struct PublicKey {\\n        bytes32 x;\\n        bytes32 y;\\n    }\\n\\n    mapping(bytes32=>PublicKey) pubkeys;\\n\\n    /**\\n     * Sets the SECP256k1 public key associated with an ENS node.\\n     * @param node The ENS node to query\\n     * @param x the X coordinate of the curve point for the public key.\\n     * @param y the Y coordinate of the curve point for the public key.\\n     */\\n    function setPubkey(bytes32 node, bytes32 x, bytes32 y) external authorised(node) {\\n        pubkeys[node] = PublicKey(x, y);\\n        emit PubkeyChanged(node, x, y);\\n    }\\n\\n    /**\\n     * Returns the SECP256k1 public key associated with an ENS node.\\n     * Defined in EIP 619.\\n     * @param node The ENS node to query\\n     * @return x The X coordinate of the curve point for the public key.\\n     * @return y The Y coordinate of the curve point for the public key.\\n     */\\n    function pubkey(bytes32 node) external view returns (bytes32 x, bytes32 y) {\\n        return (pubkeys[node].x, pubkeys[node].y);\\n    }\\n\\n    function supportsInterface(bytes4 interfaceID) virtual override public pure returns(bool) {\\n        return interfaceID == PUBKEY_INTERFACE_ID || super.supportsInterface(interfaceID);\\n    }\\n}\\n\",\"keccak256\":\"0xc055d31c586552cb87de93a6c2b0e36e9b8671a117a1a76fc1a795c6237e5b06\"},\"@ensdomains/ens-contracts/contracts/resolvers/profiles/TextResolver.sol\":{\"content\":\"pragma solidity >=0.8.4;\\nimport \\\"../ResolverBase.sol\\\";\\n\\nabstract contract TextResolver is ResolverBase {\\n    bytes4 constant private TEXT_INTERFACE_ID = 0x59d1d43c;\\n\\n    event TextChanged(bytes32 indexed node, string indexed indexedKey, string key);\\n\\n    mapping(bytes32=>mapping(string=>string)) texts;\\n\\n    /**\\n     * Sets the text data associated with an ENS node and key.\\n     * May only be called by the owner of that node in the ENS registry.\\n     * @param node The node to update.\\n     * @param key The key to set.\\n     * @param value The text data value to set.\\n     */\\n    function setText(bytes32 node, string calldata key, string calldata value) external authorised(node) {\\n        texts[node][key] = value;\\n        emit TextChanged(node, key, key);\\n    }\\n\\n    /**\\n     * Returns the text data associated with an ENS node and key.\\n     * @param node The ENS node to query.\\n     * @param key The text data key to query.\\n     * @return The associated text data.\\n     */\\n    function text(bytes32 node, string calldata key) external view returns (string memory) {\\n        return texts[node][key];\\n    }\\n\\n    function supportsInterface(bytes4 interfaceID) virtual override public pure returns(bool) {\\n        return interfaceID == TEXT_INTERFACE_ID || super.supportsInterface(interfaceID);\\n    }\\n}\\n\",\"keccak256\":\"0x22ef36660cc42fbccfc8820bee1ec3f2cfac6f8f6cf61fa3ab585e8456557cb2\"},\"@openzeppelin/contracts/token/ERC20/ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping (address => uint256) private _balances;\\n\\n    mapping (address => mapping (address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The defaut value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor (string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n\\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\\n        require(currentAllowance >= amount, \\\"ERC20: transfer amount exceeds allowance\\\");\\n        _approve(sender, _msgSender(), currentAllowance - amount);\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        uint256 senderBalance = _balances[sender];\\n        require(senderBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        _balances[sender] = senderBalance - amount;\\n        _balances[recipient] += amount;\\n\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        _balances[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        _balances[account] = accountBalance - amount;\\n        _totalSupply -= amount;\\n\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be to transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\\n}\\n\",\"keccak256\":\"0xfeccdcbf67b2006a715e5af1a4c7556004d95b2806552b5cc54e46e8eb7e887b\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\",\"keccak256\":\"0xf8e8d118a7a8b2e134181f7da655f6266aa3a0f9134b2605747139fcb0c5d835\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0x83fe24f5c04a56091e50f4a345ff504c8bff658a76d4c43b16878c8f940c53b2\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0xf930d2df426bfcfc1f7415be724f04081c96f4fb9ec8d0e3a521c07692dface0\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/SafeCast.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCast {\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value < 2**128, \\\"SafeCast: value doesn\\\\'t fit in 128 bits\\\");\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(value < 2**64, \\\"SafeCast: value doesn\\\\'t fit in 64 bits\\\");\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(value < 2**32, \\\"SafeCast: value doesn\\\\'t fit in 32 bits\\\");\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(value < 2**16, \\\"SafeCast: value doesn\\\\'t fit in 16 bits\\\");\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits.\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(value < 2**8, \\\"SafeCast: value doesn\\\\'t fit in 8 bits\\\");\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt128(int256 value) internal pure returns (int128) {\\n        require(value >= -2**127 && value < 2**127, \\\"SafeCast: value doesn\\\\'t fit in 128 bits\\\");\\n        return int128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt64(int256 value) internal pure returns (int64) {\\n        require(value >= -2**63 && value < 2**63, \\\"SafeCast: value doesn\\\\'t fit in 64 bits\\\");\\n        return int64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt32(int256 value) internal pure returns (int32) {\\n        require(value >= -2**31 && value < 2**31, \\\"SafeCast: value doesn\\\\'t fit in 32 bits\\\");\\n        return int32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt16(int256 value) internal pure returns (int16) {\\n        require(value >= -2**15 && value < 2**15, \\\"SafeCast: value doesn\\\\'t fit in 16 bits\\\");\\n        return int16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt8(int256 value) internal pure returns (int8) {\\n        require(value >= -2**7 && value < 2**7, \\\"SafeCast: value doesn\\\\'t fit in 8 bits\\\");\\n        return int8(value);\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        require(value < 2**255, \\\"SafeCast: value doesn't fit in an int256\\\");\\n        return int256(value);\\n    }\\n}\\n\",\"keccak256\":\"0xc37d85b96c2a8d7bc09f25958e0a81394bf5780286444147ddf875fa628d53ce\",\"license\":\"MIT\"},\"contracts/price-aggregator/IsaLPPricer.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IsaLPPricer {\\n    /**\\n     * @notice It returns the exchange rate of the single asset liquidity provider token.\\n     * @param saLPToken address of the single asset liquidity provider token.\\n     * @return Exchange rate for 1 saLP token in the underlying asset.\\n     */\\n    function getRateFor(address saLPToken) external view returns (uint256);\\n\\n    /**\\n     * @notice It calculates the value of the protocol token amount into the underlying asset.\\n     * @param saLPToken address of the single asset liquidity provider token\\n     * @param amount Amount of the token to convert into the underlying asset.\\n     * @return Value of the saLP token in the underlying asset.\\n     */\\n    function getValueOf(address saLPToken, uint256 amount)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /**\\n     * @notice It calculates the balance of the underlying asset for {account}.\\n     * @param saLPToken Address of the single asset liquidity provider token.\\n     * @param account Address of the account to get the balance of.\\n     * @return Balance of the underlying asset.\\n     */\\n    function getBalanceOfUnderlying(address saLPToken, address account)\\n        external\\n        returns (uint256);\\n\\n    /**\\n     * @notice Gets the underlying asset address for the {saLPToken}.\\n     * @param saLPToken address of the single asset liquidity provider token.\\n     * @return Address of the underlying asset.\\n     */\\n    function getUnderlying(address saLPToken) external view returns (address);\\n}\\n\",\"keccak256\":\"0xa37ad64548debbbef687af3809e9c51bb46c8e4d2e4b18c009625b96fc7ba96e\",\"license\":\"MIT\"},\"contracts/price-aggregator/PriceAggregator.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// Contracts\\nimport { ChainlinkPricer } from \\\"./pricers/ChainlinkPricer.sol\\\";\\n\\n// Interfaces\\nimport { IsaLPPricer } from \\\"./IsaLPPricer.sol\\\";\\nimport { AggregatorV2V3Interface } from \\\"@chainlink/contracts/src/v0.8/interfaces/AggregatorV2V3Interface.sol\\\";\\nimport { ERC20 } from \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\n\\ncontract PriceAggregator {\\n    uint256 internal constant TEN = 10;\\n    address public immutable wETH;\\n\\n    mapping(address => IsaLPPricer) public saLPPricer;\\n    ChainlinkPricer public chainlinkPricer;\\n\\n    constructor(address wETHAddress, address chainlinkPricerAddress) {\\n        wETH = wETHAddress;\\n        chainlinkPricer = ChainlinkPricer(chainlinkPricerAddress);\\n    }\\n\\n    function setAssetPricers(address pricer, address[] calldata assets)\\n        external\\n    {\\n        for (uint256 i; i < assets.length; i++) {\\n            setAssetPricer(assets[i], pricer);\\n        }\\n    }\\n\\n    function setAssetPricer(address asset, address pricer) public {\\n        saLPPricer[asset] = IsaLPPricer(pricer);\\n    }\\n\\n    /**\\n     * @notice It returns the price of the token pair as given from the Chainlink Aggregator.\\n     * @dev It tries to use ETH as a pass through asset if the direct pair is not supported.\\n     * @param src Source token address.\\n     * @param dst Destination token address.\\n     * @return uint256 The latest answer as given from Chainlink.\\n     */\\n    function getPriceFor(address src, address dst)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        return _priceFor(src, dst);\\n    }\\n\\n    /**\\n     * @notice It calculates the value of a token amount into another.\\n     * @param src Source token address.\\n     * @param dst Destination token address.\\n     * @param srcAmount Amount of the source token to convert into the destination token.\\n     * @return uint256 Value of the source token amount in destination tokens.\\n     */\\n    function getValueFor(\\n        address src,\\n        address dst,\\n        uint256 srcAmount\\n    ) external view returns (uint256) {\\n        return _valueFor(src, srcAmount, uint256(_priceFor(src, dst)));\\n    }\\n\\n    /**\\n     * @notice It calculates the value of the {src} token balance in {dst} token for the {account}.\\n     * @param account Address of the account to get the balance value of.\\n     * @param src Source token address.\\n     * @param dst Destination token address.\\n     * @return Value of the {src} token balance denoted in {dst} tokens.\\n     */\\n    function getBalanceOfFor(\\n        address account,\\n        address src,\\n        address dst\\n    ) external returns (uint256) {\\n        IsaLPPricer srcPricer = saLPPricer[src];\\n        IsaLPPricer dstPricer = saLPPricer[dst];\\n\\n        uint256 srcBalance;\\n        if (address(srcPricer) == address(0)) {\\n            srcBalance = ERC20(src).balanceOf(account);\\n        } else {\\n            srcBalance = srcPricer.getBalanceOfUnderlying(src, account);\\n            src = srcPricer.getUnderlying(src);\\n        }\\n\\n        return _valueFor(src, srcBalance, uint256(_priceFor(src, dst)));\\n    }\\n\\n    /**\\n     * @notice It calculates the value of a token amount into another.\\n     * @param src Source token address.\\n     * @param amount Amount of the source token to convert into the destination token.\\n     * @param exchangeRate The calculated exchange rate between the tokens.\\n     * @return uint256 Value of the source token amount given an exchange rate peg.\\n     */\\n    function _valueFor(\\n        address src,\\n        uint256 amount,\\n        uint256 exchangeRate\\n    ) internal view returns (uint256) {\\n        return (amount * exchangeRate) / _oneToken(src);\\n    }\\n\\n    /**\\n     * @notice it returns 10^{numberOfDecimals} for a token\\n     * @param token the address to calculate the decimals for\\n     * @return 10^number of decimals used to calculate the price and value of different token pairs\\n     */\\n    function _oneToken(address token) internal view returns (uint256) {\\n        return TEN**_decimalsFor(token);\\n    }\\n\\n    /**\\n     * @notice It gets the number of decimals for a given token.\\n     * @param addr Token address to get decimals for.\\n     * @return uint8 Number of decimals the given token.\\n     */\\n    function _decimalsFor(address addr) internal view returns (uint8) {\\n        return ERC20(addr).decimals();\\n    }\\n\\n    /**\\n     * @notice it tries to calculate a price from Compound and Chainlink.\\n     * @dev if no price is found on compound, then calculate it on chainlink\\n     * @param src the token address to calculate the price for in dst\\n     * @param dst the token address to retrieve the price of src\\n     * @return price_ the price of src in dst\\n     */\\n    function _priceFor(address src, address dst)\\n        private\\n        view\\n        returns (uint256 price_)\\n    {\\n        IsaLPPricer srcPricer = saLPPricer[src];\\n        IsaLPPricer dstPricer = saLPPricer[dst];\\n\\n        // ETH / ASSET\\n        if (src == wETH && address(dstPricer) == address(0)) {\\n            // Get destination asset Chainlink price in ETH\\n            uint256 dstEthPrice = chainlinkPricer.getEthPrice(dst);\\n            // Since the source asset is ETH and the price is in ETH, we need the inverse\\n            return _scale(_inverseRate(dstEthPrice, 18), 18, _decimalsFor(dst));\\n        }\\n\\n        // ASSET / ETH\\n        if (dst == wETH && address(srcPricer) == address(0)) {\\n            // Get source asset Chainlink price in ETH\\n            uint256 srcEthPrice = chainlinkPricer.getEthPrice(src);\\n            return srcEthPrice;\\n        }\\n\\n        // ASSET / ASSET\\n        if (\\n            address(srcPricer) == address(0) && address(dstPricer) == address(0)\\n        ) {\\n            // Get source asset Chainlink price in ETH\\n            uint256 srcEthPrice = chainlinkPricer.getEthPrice(src);\\n            // Get destination asset Chainlink price in ETH\\n            uint256 dstEthPrice = chainlinkPricer.getEthPrice(dst);\\n            // Merge the 2 rates\\n            return _mergeRates(srcEthPrice, dstEthPrice, dst);\\n        }\\n\\n        // saLP / ASSET\\n        if (\\n            address(srcPricer) != address(0) && address(dstPricer) == address(0)\\n        ) {\\n            // Get the underlying source asset\\n            address srcUnderlying = srcPricer.getUnderlying(src);\\n            // Get source asset exchange rate for the underlying asset\\n            uint256 srcExchangeRate = srcPricer.getRateFor(src);\\n            if (srcUnderlying == dst) {\\n                return srcExchangeRate;\\n            } else {\\n                return\\n                    _mergeRates(\\n                        srcExchangeRate,\\n                        _priceFor(dst, srcUnderlying),\\n                        dst\\n                    );\\n            }\\n        }\\n\\n        // Get the underlying destination asset\\n        address dstUnderlying = dstPricer.getUnderlying(dst);\\n\\n        // ASSET / saLP\\n        if (\\n            address(srcPricer) == address(0) && address(dstPricer) != address(0)\\n        ) {\\n            // Get destination asset exchange rate for the underlying asset\\n            uint256 dstExchangeRate = dstPricer.getRateFor(dst);\\n            // If the source asset and underlying destination asset are the same, inverse the saLP asset rate\\n            if (src == dstUnderlying) {\\n                return\\n                    _inverseRate(\\n                        _scale(\\n                            dstExchangeRate,\\n                            _decimalsFor(dst),\\n                            _decimalsFor(src)\\n                        ),\\n                        _decimalsFor(src)\\n                    );\\n            } else {\\n                return\\n                    _mergeRates(\\n                        _priceFor(src, dstUnderlying),\\n                        dstExchangeRate,\\n                        dst\\n                    );\\n            }\\n        }\\n\\n        // saLP / saLP\\n\\n        // Get the underlying destination asset\\n        return\\n            _valueFor(\\n                dstUnderlying,\\n                _priceFor(src, dstUnderlying),\\n                _priceFor(dstUnderlying, dst)\\n            );\\n    }\\n\\n    /**\\n     * @notice Scales the {value} by the difference in decimal values.\\n     * @param value the the value of the src in dst\\n     * @param srcDecimals src token decimals\\n     * @param dstDecimals dst token decimals\\n     * @return the price of src in dst after scaling the difference in decimal values\\n     */\\n    function _scale(\\n        uint256 value,\\n        uint256 srcDecimals,\\n        uint256 dstDecimals\\n    ) internal pure returns (uint256) {\\n        if (dstDecimals > srcDecimals) {\\n            return value * (TEN**(dstDecimals - srcDecimals));\\n        } else {\\n            return value / (TEN**(srcDecimals - dstDecimals));\\n        }\\n    }\\n\\n    function _inverseRate(uint256 rate, uint8 dstDecimals)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return (TEN**(dstDecimals + dstDecimals)) / rate;\\n    }\\n\\n    function _mergeRates(\\n        uint256 rate1,\\n        uint256 rate2,\\n        address dst\\n    ) internal view returns (uint256) {\\n        return\\n            rate1 == 0 ? rate2 : ((rate1 * (TEN**_decimalsFor(dst))) / rate2);\\n    }\\n}\\n\",\"keccak256\":\"0x667e7a009024efdaef2f901747e52c93c188ca1c8bb053a9b38a9006d60d91ed\",\"license\":\"MIT\"},\"contracts/price-aggregator/pricers/ChainlinkPricer.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// Interfaces\\nimport { AggregatorV2V3Interface as ChainlinkAgg } from \\\"@chainlink/contracts/src/v0.8/interfaces/AggregatorV2V3Interface.sol\\\";\\nimport { ERC20 } from \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\n\\n// Libraries\\nimport { ENS } from \\\"../../shared/libraries/ENSLib.sol\\\";\\nimport { StringsLib } from \\\"../../shared/libraries/StringsLib.sol\\\";\\nimport { SafeCast } from \\\"@openzeppelin/contracts/utils/math/SafeCast.sol\\\";\\n\\ncontract ChainlinkPricer {\\n    using StringsLib for string;\\n\\n    // Chainlink ENS resolver\\n    address public immutable ENS_RESOLVER;\\n    // namehash of `data.eth` domain\\n    bytes32 public constant ENS_DOMAIN =\\n        0x4a9dd6923a809a49d009b308182940df46ac3a45ee16c1133f90db66596dae1f;\\n\\n    constructor(address ensResolver) {\\n        ENS_RESOLVER = ensResolver;\\n    }\\n\\n    function getEthPrice(address token) external view returns (uint256 price_) {\\n        price_ = SafeCast.toUint256(\\n            ChainlinkAgg(getEthAggregator(token)).latestAnswer()\\n        );\\n    }\\n\\n    function getEthAggregator(address token) public view returns (address) {\\n        string memory name = _getTokenSymbol(token).concat(\\\"-eth\\\");\\n        return ENS.resolve(ENS_RESOLVER, ENS.subnode(name, ENS_DOMAIN));\\n    }\\n\\n    function _getTokenSymbol(address token)\\n        internal\\n        view\\n        returns (string memory)\\n    {\\n        string memory symbol_ = ERC20(token).symbol();\\n        if (symbol_.compareTo(\\\"WBTC\\\")) {\\n            return \\\"btc\\\";\\n        }\\n        if (symbol_.compareTo(\\\"WMATIC\\\")) {\\n            return \\\"matic\\\";\\n        }\\n        return symbol_.lower();\\n    }\\n}\\n\",\"keccak256\":\"0xe4213dd0f19e5a7514e95936b7a9990aa2d981469bf7062253820c77a7155f58\",\"license\":\"MIT\"},\"contracts/shared/libraries/ENSLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport { ENSRegistry } from \\\"@ensdomains/ens-contracts/contracts/registry/ENSRegistry.sol\\\";\\nimport { PublicResolver } from \\\"@ensdomains/ens-contracts/contracts/resolvers/PublicResolver.sol\\\";\\n\\nlibrary ENS {\\n    bytes32 public constant ETH_NAMEHASH =\\n        0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;\\n\\n    function registryResolve(address registry, bytes32 node)\\n        internal\\n        view\\n        returns (address)\\n    {\\n        return resolve(resolver(registry, node), node);\\n    }\\n\\n    function resolve(address resolver, bytes32 node)\\n        internal\\n        view\\n        returns (address)\\n    {\\n        return PublicResolver(resolver).addr(node);\\n    }\\n\\n    function resolver(address registry, bytes32 node)\\n        internal\\n        view\\n        returns (address)\\n    {\\n        return ENSRegistry(registry).resolver(node);\\n    }\\n\\n    function subnode(string memory name, bytes32 node)\\n        internal\\n        pure\\n        returns (bytes32 namehash_)\\n    {\\n        namehash_ = subnode(keccak256(abi.encodePacked(name)), node);\\n    }\\n\\n    function subnode(bytes32 label, bytes32 node)\\n        internal\\n        pure\\n        returns (bytes32 namehash_)\\n    {\\n        namehash_ = keccak256(abi.encodePacked(node, label));\\n    }\\n}\\n\",\"keccak256\":\"0x8da1749a1cd853398492e489f901bb9d8cd6ad26a92aea9138d20e5ecf5a20c9\",\"license\":\"MIT\"},\"contracts/shared/libraries/StringsLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * Strings Library\\n *\\n * In summary this is a simple library of string functions which make simple\\n * string operations less tedious in solidity.\\n *\\n * Please be aware these functions can be quite gas heavy so use them only when\\n * necessary not to clog the blockchain with expensive transactions.\\n *\\n * @author James Lockhart <james@n3tw0rk.co.uk>\\n */\\nlibrary StringsLib {\\n    /**\\n     * Concat\\n     *\\n     * Appends two strings together and returns a new value\\n     *\\n     * @param _base When being used for a data type this is the extended object\\n     *              otherwise this is the string which will be the concatenated\\n     *              prefix\\n     * @param _value The value to be the concatenated suffix\\n     * @return string The resulting string from combining the base and value\\n     */\\n    function concat(string memory _base, string memory _value)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        return string(abi.encodePacked(_base, _value));\\n    }\\n\\n    /**\\n     * Index Of\\n     *\\n     * Locates and returns the position of a character within a string\\n     *\\n     * @param _base When being used for a data type this is the extended object\\n     *              otherwise this is the string acting as the haystack to be\\n     *              searched\\n     * @param _value The needle to search for, at present this is currently\\n     *               limited to one character\\n     * @return int The position of the needle starting from 0 and returning -1\\n     *             in the case of no matches found\\n     */\\n    function indexOf(string memory _base, string memory _value)\\n        internal\\n        pure\\n        returns (int256)\\n    {\\n        return _indexOf(_base, _value, 0);\\n    }\\n\\n    /**\\n     * Index Of\\n     *\\n     * Locates and returns the position of a character within a string starting\\n     * from a defined offset\\n     *\\n     * @param _base When being used for a data type this is the extended object\\n     *              otherwise this is the string acting as the haystack to be\\n     *              searched\\n     * @param _value The needle to search for, at present this is currently\\n     *               limited to one character\\n     * @param _offset The starting point to start searching from which can start\\n     *                from 0, but must not exceed the length of the string\\n     * @return int The position of the needle starting from 0 and returning -1\\n     *             in the case of no matches found\\n     */\\n    function _indexOf(\\n        string memory _base,\\n        string memory _value,\\n        uint256 _offset\\n    ) internal pure returns (int256) {\\n        bytes memory _baseBytes = bytes(_base);\\n        bytes memory _valueBytes = bytes(_value);\\n\\n        assert(_valueBytes.length == 1);\\n\\n        for (uint256 i = _offset; i < _baseBytes.length; i++) {\\n            if (_baseBytes[i] == _valueBytes[0]) {\\n                return int256(i);\\n            }\\n        }\\n\\n        return -1;\\n    }\\n\\n    /**\\n     * Length\\n     *\\n     * Returns the length of the specified string\\n     *\\n     * @param _base When being used for a data type this is the extended object\\n     *              otherwise this is the string to be measured\\n     * @return uint The length of the passed string\\n     */\\n    function length(string memory _base) internal pure returns (uint256) {\\n        bytes memory _baseBytes = bytes(_base);\\n        return _baseBytes.length;\\n    }\\n\\n    /**\\n     * Sub String\\n     *\\n     * Extracts the beginning part of a string based on the desired length\\n     *\\n     * @param _base When being used for a data type this is the extended object\\n     *              otherwise this is the string that will be used for\\n     *              extracting the sub string from\\n     * @param _length The length of the sub string to be extracted from the base\\n     * @return string The extracted sub string\\n     */\\n    function substring(string memory _base, int256 _length)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        return _substring(_base, _length, 0);\\n    }\\n\\n    /**\\n     * Sub String\\n     *\\n     * Extracts the part of a string based on the desired length and offset. The\\n     * offset and length must not exceed the lenth of the base string.\\n     *\\n     * @param _base When being used for a data type this is the extended object\\n     *              otherwise this is the string that will be used for\\n     *              extracting the sub string from\\n     * @param _length The length of the sub string to be extracted from the base\\n     * @param _offset The starting point to extract the sub string from\\n     * @return string The extracted sub string\\n     */\\n    function _substring(\\n        string memory _base,\\n        int256 _length,\\n        int256 _offset\\n    ) internal pure returns (string memory) {\\n        bytes memory _baseBytes = bytes(_base);\\n\\n        assert(uint256(_offset + _length) <= _baseBytes.length);\\n\\n        string memory _tmp = new string(uint256(_length));\\n        bytes memory _tmpBytes = bytes(_tmp);\\n\\n        uint256 j = 0;\\n        for (\\n            uint256 i = uint256(_offset);\\n            i < uint256(_offset + _length);\\n            i++\\n        ) {\\n            _tmpBytes[j++] = _baseBytes[i];\\n        }\\n\\n        return string(_tmpBytes);\\n    }\\n\\n    /**\\n     * String Split (Very high gas cost)\\n     *\\n     * Splits a string into an array of strings based off the delimiter value.\\n     * Please note this can be quite a gas expensive function due to the use of\\n     * storage so only use if really required.\\n     *\\n     * @param _base When being used for a data type this is the extended object\\n     *               otherwise this is the string value to be split.\\n     * @param _value The delimiter to split the string on which must be a single\\n     *               character\\n     * @return splitArr An array of values split based off the delimiter, but\\n     *                  do not container the delimiter.\\n     */\\n    function split(string memory _base, string memory _value)\\n        internal\\n        pure\\n        returns (string[] memory splitArr)\\n    {\\n        bytes memory _baseBytes = bytes(_base);\\n\\n        uint256 _offset = 0;\\n        uint256 _splitsCount = 1;\\n        while (_offset < _baseBytes.length - 1) {\\n            int256 _limit = _indexOf(_base, _value, _offset);\\n            if (_limit == -1) break;\\n            else {\\n                _splitsCount++;\\n                _offset = uint256(_limit) + 1;\\n            }\\n        }\\n\\n        splitArr = new string[](_splitsCount);\\n\\n        _offset = 0;\\n        _splitsCount = 0;\\n        while (_offset < _baseBytes.length - 1) {\\n            int256 _limit = _indexOf(_base, _value, _offset);\\n            if (_limit == -1) {\\n                _limit = int256(_baseBytes.length);\\n            }\\n\\n            string memory _tmp = new string(uint256(_limit) - _offset);\\n            bytes memory _tmpBytes = bytes(_tmp);\\n\\n            uint256 j = 0;\\n            for (uint256 i = _offset; i < uint256(_limit); i++) {\\n                _tmpBytes[j++] = _baseBytes[i];\\n            }\\n            _offset = uint256(_limit) + 1;\\n            splitArr[_splitsCount++] = string(_tmpBytes);\\n        }\\n        return splitArr;\\n    }\\n\\n    /**\\n     * Compare To\\n     *\\n     * Compares the characters of two strings, to ensure that they have an\\n     * identical footprint\\n     *\\n     * @param _base When being used for a data type this is the extended object\\n     *               otherwise this is the string base to compare against\\n     * @param _value The string the base is being compared to\\n     * @return bool Simply notates if the two string have an equivalent\\n     */\\n    function compareTo(string memory _base, string memory _value)\\n        internal\\n        pure\\n        returns (bool)\\n    {\\n        bytes memory _baseBytes = bytes(_base);\\n        bytes memory _valueBytes = bytes(_value);\\n\\n        if (_baseBytes.length != _valueBytes.length) {\\n            return false;\\n        }\\n\\n        for (uint256 i = 0; i < _baseBytes.length; i++) {\\n            if (_baseBytes[i] != _valueBytes[i]) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * Compare To Ignore Case (High gas cost)\\n     *\\n     * Compares the characters of two strings, converting them to the same case\\n     * where applicable to alphabetic characters to distinguish if the values\\n     * match.\\n     *\\n     * @param _base When being used for a data type this is the extended object\\n     *               otherwise this is the string base to compare against\\n     * @param _value The string the base is being compared to\\n     * @return bool Simply notates if the two string have an equivalent value\\n     *              discarding case\\n     */\\n    function compareToIgnoreCase(string memory _base, string memory _value)\\n        internal\\n        pure\\n        returns (bool)\\n    {\\n        bytes memory _baseBytes = bytes(_base);\\n        bytes memory _valueBytes = bytes(_value);\\n\\n        if (_baseBytes.length != _valueBytes.length) {\\n            return false;\\n        }\\n\\n        for (uint256 i = 0; i < _baseBytes.length; i++) {\\n            if (\\n                _baseBytes[i] != _valueBytes[i] &&\\n                _upper(_baseBytes[i]) != _upper(_valueBytes[i])\\n            ) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * Upper\\n     *\\n     * Converts all the values of a string to their corresponding upper case\\n     * value.\\n     *\\n     * @param _base When being used for a data type this is the extended object\\n     *              otherwise this is the string base to convert to upper case\\n     * @return string\\n     */\\n    function upper(string memory _base) internal pure returns (string memory) {\\n        bytes memory _baseBytes = bytes(_base);\\n        for (uint256 i = 0; i < _baseBytes.length; i++) {\\n            _baseBytes[i] = _upper(_baseBytes[i]);\\n        }\\n        return string(_baseBytes);\\n    }\\n\\n    /**\\n     * Lower\\n     *\\n     * Converts all the values of a string to their corresponding lower case\\n     * value.\\n     *\\n     * @param _base When being used for a data type this is the extended object\\n     *              otherwise this is the string base to convert to lower case\\n     * @return string\\n     */\\n    function lower(string memory _base) internal pure returns (string memory) {\\n        bytes memory _baseBytes = bytes(_base);\\n        for (uint256 i = 0; i < _baseBytes.length; i++) {\\n            _baseBytes[i] = _lower(_baseBytes[i]);\\n        }\\n        return string(_baseBytes);\\n    }\\n\\n    /**\\n     * Upper\\n     *\\n     * Convert an alphabetic character to upper case and return the original\\n     * value when not alphabetic\\n     *\\n     * @param _b1 The byte to be converted to upper case\\n     * @return bytes1 The converted value if the passed value was alphabetic\\n     *                and in a lower case otherwise returns the original value\\n     */\\n    function _upper(bytes1 _b1) private pure returns (bytes1) {\\n        if (_b1 >= 0x61 && _b1 <= 0x7A) {\\n            return bytes1(uint8(_b1) - 32);\\n        }\\n\\n        return _b1;\\n    }\\n\\n    /**\\n     * Lower\\n     *\\n     * Convert an alphabetic character to lower case and return the original\\n     * value when not alphabetic\\n     *\\n     * @param _b1 The byte to be converted to lower case\\n     * @return bytes1 The converted value if the passed value was alphabetic\\n     *                and in a upper case otherwise returns the original value\\n     */\\n    function _lower(bytes1 _b1) private pure returns (bytes1) {\\n        if (_b1 >= 0x41 && _b1 <= 0x5A) {\\n            return bytes1(uint8(_b1) + 32);\\n        }\\n\\n        return _b1;\\n    }\\n}\\n\",\"keccak256\":\"0x1d85cf593c0c2b92fed1f1db387d09e393e392c63ba905a4f66ac88789acba59\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60a060405234801561001057600080fd5b5060405161100e38038061100e83398101604081905261002f91610082565b60609190911b6001600160601b031916608052600180546001600160a01b0319166001600160a01b039092169190911790556100b4565b80516001600160a01b038116811461007d57600080fd5b919050565b60008060408385031215610094578182fd5b61009d83610066565b91506100ab60208401610066565b90509250929050565b60805160601c610f2e6100e0600039600081816101470152818161043d01526105250152610f2e6000f3fe608060405234801561001057600080fd5b50600436106100885760003560e01c8063c05b1ec31161005b578063c05b1ec3146100ee578063d12a6cc914610101578063f242862114610142578063f5fd09e71461016957600080fd5b806335a7206d1461008d5780633fd3ec8f146100b35780634d6f21a9146100c85780636261eb7c146100db575b600080fd5b6100a061009b366004610bbb565b61017c565b6040519081526020015b60405180910390f35b6100c66100c1366004610bbb565b610191565b005b6100a06100d6366004610bf3565b6101bf565b6100c66100e9366004610c7d565b610393565b6100a06100fc366004610c3d565b6103f4565b61012a61010f366004610b83565b6000602081905290815260409020546001600160a01b031681565b6040516001600160a01b0390911681526020016100aa565b61012a7f000000000000000000000000000000000000000000000000000000000000000081565b60015461012a906001600160a01b031681565b6000610188838361040d565b90505b92915050565b6001600160a01b03918216600090815260208190526040902080546001600160a01b03191691909216179055565b6001600160a01b0380831660009081526020819052604080822054848416835290822054919290811691168282610270576040516370a0823160e01b81526001600160a01b0388811660048301528716906370a082319060240160206040518083038186803b15801561023157600080fd5b505afa158015610245573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102699190610d00565b9050610372565b604051621c9eb960ea1b81526001600160a01b038781166004830152888116602483015284169063727ae40090604401602060405180830381600087803b1580156102ba57600080fd5b505af11580156102ce573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102f29190610d00565b604051634e89a71160e01b81526001600160a01b03888116600483015291925090841690634e89a7119060240160206040518083038186803b15801561033757600080fd5b505afa15801561034b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061036f9190610b9f565b95505b6103868682610381898961040d565b610a2c565b93505050505b9392505050565b60005b818110156103ee576103dc8383838181106103c157634e487b7160e01b600052603260045260246000fd5b90506020020160208101906103d69190610b83565b85610191565b806103e681610eaf565b915050610396565b50505050565b60006104058483610381878761040d565b949350505050565b6001600160a01b0380831660008181526020819052604080822054858516835290822054919390811692918116917f000000000000000000000000000000000000000000000000000000000000000090911614801561047357506001600160a01b038116155b156105235760015460405163a6b24a8f60e01b81526001600160a01b038681166004830152600092169063a6b24a8f9060240160206040518083038186803b1580156104be57600080fd5b505afa1580156104d2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104f69190610d00565b9050610519610506826012610a4b565b601261051188610a6d565b60ff16610ae0565b935050505061018b565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316846001600160a01b031614801561056b57506001600160a01b038216155b156105f95760015460405163a6b24a8f60e01b81526001600160a01b038781166004830152600092169063a6b24a8f9060240160206040518083038186803b1580156105b657600080fd5b505afa1580156105ca573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105ee9190610d00565b935061018b92505050565b6001600160a01b03821615801561061757506001600160a01b038116155b156107355760015460405163a6b24a8f60e01b81526001600160a01b038781166004830152600092169063a6b24a8f9060240160206040518083038186803b15801561066257600080fd5b505afa158015610676573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061069a9190610d00565b60015460405163a6b24a8f60e01b81526001600160a01b0388811660048301529293506000929091169063a6b24a8f9060240160206040518083038186803b1580156106e557600080fd5b505afa1580156106f9573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061071d9190610d00565b905061072a828288610b2f565b94505050505061018b565b6001600160a01b0382161580159061075457506001600160a01b038116155b1561089057604051634e89a71160e01b81526001600160a01b03868116600483015260009190841690634e89a7119060240160206040518083038186803b15801561079e57600080fd5b505afa1580156107b2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107d69190610b9f565b6040516302d4999160e11b81526001600160a01b0388811660048301529192506000918516906305a933229060240160206040518083038186803b15801561081d57600080fd5b505afa158015610831573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108559190610d00565b9050856001600160a01b0316826001600160a01b0316141561087c57935061018b92505050565b61072a8161088a888561040d565b88610b2f565b604051634e89a71160e01b81526001600160a01b03858116600483015260009190831690634e89a7119060240160206040518083038186803b1580156108d557600080fd5b505afa1580156108e9573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061090d9190610b9f565b90506001600160a01b03831615801561092e57506001600160a01b03821615155b15610a0a576040516302d4999160e11b81526001600160a01b038681166004830152600091908416906305a933229060240160206040518083038186803b15801561097857600080fd5b505afa15801561098c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109b09190610d00565b9050816001600160a01b0316876001600160a01b031614156109f65761072a6109e8826109dc89610a6d565b60ff166105118b610a6d565b6109f189610a6d565b610a4b565b61072a610a03888461040d565b8288610b2f565b610a2281610a18888461040d565b610381848961040d565b9695505050505050565b6000610a3784610b6d565b610a418385610e79565b6104059190610d5e565b600082610a588380610d39565b610a6390600a610dcd565b6101889190610d5e565b6000816001600160a01b031663313ce5676040518163ffffffff1660e01b815260040160206040518083038186803b158015610aa857600080fd5b505afa158015610abc573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061018b9190610d18565b600082821115610b1057610af48383610e98565b610aff90600a610dc1565b610b099085610e79565b905061038c565b610b1a8284610e98565b610b2590600a610dc1565b610b099085610d5e565b60008315610b655782610b4183610a6d565b610b4c90600a610dcd565b610b569086610e79565b610b609190610d5e565b610405565b509092915050565b6000610b7882610a6d565b61018b90600a610dcd565b600060208284031215610b94578081fd5b813561038c81610ee0565b600060208284031215610bb0578081fd5b815161038c81610ee0565b60008060408385031215610bcd578081fd5b8235610bd881610ee0565b91506020830135610be881610ee0565b809150509250929050565b600080600060608486031215610c07578081fd5b8335610c1281610ee0565b92506020840135610c2281610ee0565b91506040840135610c3281610ee0565b809150509250925092565b600080600060608486031215610c51578283fd5b8335610c5c81610ee0565b92506020840135610c6c81610ee0565b929592945050506040919091013590565b600080600060408486031215610c91578283fd5b8335610c9c81610ee0565b9250602084013567ffffffffffffffff80821115610cb8578384fd5b818601915086601f830112610ccb578384fd5b813581811115610cd9578485fd5b8760208260051b8501011115610ced578485fd5b6020830194508093505050509250925092565b600060208284031215610d11578081fd5b5051919050565b600060208284031215610d29578081fd5b815160ff8116811461038c578182fd5b600060ff821660ff84168060ff03821115610d5657610d56610eca565b019392505050565b600082610d7957634e487b7160e01b81526012600452602481fd5b500490565b600181815b80851115610db9578160001904821115610d9f57610d9f610eca565b80851615610dac57918102915b93841c9390800290610d83565b509250929050565b60006101888383610dd8565b600061018860ff8416835b600082610de75750600161018b565b81610df45750600061018b565b8160018114610e0a5760028114610e1457610e30565b600191505061018b565b60ff841115610e2557610e25610eca565b50506001821b61018b565b5060208310610133831016604e8410600b8410161715610e53575081810a61018b565b610e5d8383610d7e565b8060001904821115610e7157610e71610eca565b029392505050565b6000816000190483118215151615610e9357610e93610eca565b500290565b600082821015610eaa57610eaa610eca565b500390565b6000600019821415610ec357610ec3610eca565b5060010190565b634e487b7160e01b600052601160045260246000fd5b6001600160a01b0381168114610ef557600080fd5b5056fea2646970667358221220adeffa61b623951cccecb215a4fcf0e0947ff108f484d6bc8aec1b1b10c7bbc064736f6c63430008040033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100885760003560e01c8063c05b1ec31161005b578063c05b1ec3146100ee578063d12a6cc914610101578063f242862114610142578063f5fd09e71461016957600080fd5b806335a7206d1461008d5780633fd3ec8f146100b35780634d6f21a9146100c85780636261eb7c146100db575b600080fd5b6100a061009b366004610bbb565b61017c565b6040519081526020015b60405180910390f35b6100c66100c1366004610bbb565b610191565b005b6100a06100d6366004610bf3565b6101bf565b6100c66100e9366004610c7d565b610393565b6100a06100fc366004610c3d565b6103f4565b61012a61010f366004610b83565b6000602081905290815260409020546001600160a01b031681565b6040516001600160a01b0390911681526020016100aa565b61012a7f000000000000000000000000000000000000000000000000000000000000000081565b60015461012a906001600160a01b031681565b6000610188838361040d565b90505b92915050565b6001600160a01b03918216600090815260208190526040902080546001600160a01b03191691909216179055565b6001600160a01b0380831660009081526020819052604080822054848416835290822054919290811691168282610270576040516370a0823160e01b81526001600160a01b0388811660048301528716906370a082319060240160206040518083038186803b15801561023157600080fd5b505afa158015610245573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102699190610d00565b9050610372565b604051621c9eb960ea1b81526001600160a01b038781166004830152888116602483015284169063727ae40090604401602060405180830381600087803b1580156102ba57600080fd5b505af11580156102ce573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102f29190610d00565b604051634e89a71160e01b81526001600160a01b03888116600483015291925090841690634e89a7119060240160206040518083038186803b15801561033757600080fd5b505afa15801561034b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061036f9190610b9f565b95505b6103868682610381898961040d565b610a2c565b93505050505b9392505050565b60005b818110156103ee576103dc8383838181106103c157634e487b7160e01b600052603260045260246000fd5b90506020020160208101906103d69190610b83565b85610191565b806103e681610eaf565b915050610396565b50505050565b60006104058483610381878761040d565b949350505050565b6001600160a01b0380831660008181526020819052604080822054858516835290822054919390811692918116917f000000000000000000000000000000000000000000000000000000000000000090911614801561047357506001600160a01b038116155b156105235760015460405163a6b24a8f60e01b81526001600160a01b038681166004830152600092169063a6b24a8f9060240160206040518083038186803b1580156104be57600080fd5b505afa1580156104d2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104f69190610d00565b9050610519610506826012610a4b565b601261051188610a6d565b60ff16610ae0565b935050505061018b565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316846001600160a01b031614801561056b57506001600160a01b038216155b156105f95760015460405163a6b24a8f60e01b81526001600160a01b038781166004830152600092169063a6b24a8f9060240160206040518083038186803b1580156105b657600080fd5b505afa1580156105ca573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105ee9190610d00565b935061018b92505050565b6001600160a01b03821615801561061757506001600160a01b038116155b156107355760015460405163a6b24a8f60e01b81526001600160a01b038781166004830152600092169063a6b24a8f9060240160206040518083038186803b15801561066257600080fd5b505afa158015610676573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061069a9190610d00565b60015460405163a6b24a8f60e01b81526001600160a01b0388811660048301529293506000929091169063a6b24a8f9060240160206040518083038186803b1580156106e557600080fd5b505afa1580156106f9573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061071d9190610d00565b905061072a828288610b2f565b94505050505061018b565b6001600160a01b0382161580159061075457506001600160a01b038116155b1561089057604051634e89a71160e01b81526001600160a01b03868116600483015260009190841690634e89a7119060240160206040518083038186803b15801561079e57600080fd5b505afa1580156107b2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107d69190610b9f565b6040516302d4999160e11b81526001600160a01b0388811660048301529192506000918516906305a933229060240160206040518083038186803b15801561081d57600080fd5b505afa158015610831573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108559190610d00565b9050856001600160a01b0316826001600160a01b0316141561087c57935061018b92505050565b61072a8161088a888561040d565b88610b2f565b604051634e89a71160e01b81526001600160a01b03858116600483015260009190831690634e89a7119060240160206040518083038186803b1580156108d557600080fd5b505afa1580156108e9573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061090d9190610b9f565b90506001600160a01b03831615801561092e57506001600160a01b03821615155b15610a0a576040516302d4999160e11b81526001600160a01b038681166004830152600091908416906305a933229060240160206040518083038186803b15801561097857600080fd5b505afa15801561098c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109b09190610d00565b9050816001600160a01b0316876001600160a01b031614156109f65761072a6109e8826109dc89610a6d565b60ff166105118b610a6d565b6109f189610a6d565b610a4b565b61072a610a03888461040d565b8288610b2f565b610a2281610a18888461040d565b610381848961040d565b9695505050505050565b6000610a3784610b6d565b610a418385610e79565b6104059190610d5e565b600082610a588380610d39565b610a6390600a610dcd565b6101889190610d5e565b6000816001600160a01b031663313ce5676040518163ffffffff1660e01b815260040160206040518083038186803b158015610aa857600080fd5b505afa158015610abc573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061018b9190610d18565b600082821115610b1057610af48383610e98565b610aff90600a610dc1565b610b099085610e79565b905061038c565b610b1a8284610e98565b610b2590600a610dc1565b610b099085610d5e565b60008315610b655782610b4183610a6d565b610b4c90600a610dcd565b610b569086610e79565b610b609190610d5e565b610405565b509092915050565b6000610b7882610a6d565b61018b90600a610dcd565b600060208284031215610b94578081fd5b813561038c81610ee0565b600060208284031215610bb0578081fd5b815161038c81610ee0565b60008060408385031215610bcd578081fd5b8235610bd881610ee0565b91506020830135610be881610ee0565b809150509250929050565b600080600060608486031215610c07578081fd5b8335610c1281610ee0565b92506020840135610c2281610ee0565b91506040840135610c3281610ee0565b809150509250925092565b600080600060608486031215610c51578283fd5b8335610c5c81610ee0565b92506020840135610c6c81610ee0565b929592945050506040919091013590565b600080600060408486031215610c91578283fd5b8335610c9c81610ee0565b9250602084013567ffffffffffffffff80821115610cb8578384fd5b818601915086601f830112610ccb578384fd5b813581811115610cd9578485fd5b8760208260051b8501011115610ced578485fd5b6020830194508093505050509250925092565b600060208284031215610d11578081fd5b5051919050565b600060208284031215610d29578081fd5b815160ff8116811461038c578182fd5b600060ff821660ff84168060ff03821115610d5657610d56610eca565b019392505050565b600082610d7957634e487b7160e01b81526012600452602481fd5b500490565b600181815b80851115610db9578160001904821115610d9f57610d9f610eca565b80851615610dac57918102915b93841c9390800290610d83565b509250929050565b60006101888383610dd8565b600061018860ff8416835b600082610de75750600161018b565b81610df45750600061018b565b8160018114610e0a5760028114610e1457610e30565b600191505061018b565b60ff841115610e2557610e25610eca565b50506001821b61018b565b5060208310610133831016604e8410600b8410161715610e53575081810a61018b565b610e5d8383610d7e565b8060001904821115610e7157610e71610eca565b029392505050565b6000816000190483118215151615610e9357610e93610eca565b500290565b600082821015610eaa57610eaa610eca565b500390565b6000600019821415610ec357610ec3610eca565b5060010190565b634e487b7160e01b600052601160045260246000fd5b6001600160a01b0381168114610ef557600080fd5b5056fea2646970667358221220adeffa61b623951cccecb215a4fcf0e0947ff108f484d6bc8aec1b1b10c7bbc064736f6c63430008040033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "getBalanceOfFor(address,address,address)": {
        "params": {
          "account": "Address of the account to get the balance value of.",
          "dst": "Destination token address.",
          "src": "Source token address."
        },
        "returns": {
          "_0": "Value of the {src} token balance denoted in {dst} tokens."
        }
      },
      "getPriceFor(address,address)": {
        "details": "It tries to use ETH as a pass through asset if the direct pair is not supported.",
        "params": {
          "dst": "Destination token address.",
          "src": "Source token address."
        },
        "returns": {
          "_0": "uint256 The latest answer as given from Chainlink."
        }
      },
      "getValueFor(address,address,uint256)": {
        "params": {
          "dst": "Destination token address.",
          "src": "Source token address.",
          "srcAmount": "Amount of the source token to convert into the destination token."
        },
        "returns": {
          "_0": "uint256 Value of the source token amount in destination tokens."
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "getBalanceOfFor(address,address,address)": {
        "notice": "It calculates the value of the {src} token balance in {dst} token for the {account}."
      },
      "getPriceFor(address,address)": {
        "notice": "It returns the price of the token pair as given from the Chainlink Aggregator."
      },
      "getValueFor(address,address,uint256)": {
        "notice": "It calculates the value of a token amount into another."
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 24083,
        "contract": "contracts/price-aggregator/PriceAggregator.sol:PriceAggregator",
        "label": "saLPPricer",
        "offset": 0,
        "slot": "0",
        "type": "t_mapping(t_address,t_contract(IsaLPPricer)24029)"
      },
      {
        "astId": 24086,
        "contract": "contracts/price-aggregator/PriceAggregator.sol:PriceAggregator",
        "label": "chainlinkPricer",
        "offset": 0,
        "slot": "1",
        "type": "t_contract(ChainlinkPricer)24854"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_contract(ChainlinkPricer)24854": {
        "encoding": "inplace",
        "label": "contract ChainlinkPricer",
        "numberOfBytes": "20"
      },
      "t_contract(IsaLPPricer)24029": {
        "encoding": "inplace",
        "label": "contract IsaLPPricer",
        "numberOfBytes": "20"
      },
      "t_mapping(t_address,t_contract(IsaLPPricer)24029)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => contract IsaLPPricer)",
        "numberOfBytes": "32",
        "value": "t_contract(IsaLPPricer)24029"
      }
    }
  }
}